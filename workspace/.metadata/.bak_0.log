!SESSION 2020-09-24 18:02:40.164 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-09-24 18:03:22.070
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-09-24 18:03:22.070
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-09-24 18:03:24.306
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-24 18:03:24.307
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@702432cc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5039c2cf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-24 18:03:31.752
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 2 2 2020-09-24 18:05:44.283
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-09-25 08:57:27.424 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-09-25 08:57:56.080
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-09-25 08:57:56.080
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-09-25 08:57:59.530
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-25 08:57:59.530
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@ecb8b3e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e764e5c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-25 08:58:07.744
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 2 2 2020-09-25 08:58:41.923
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-09-28 13:27:42.359 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-09-28 13:28:30.243
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-09-28 13:28:30.243
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-09-28 13:28:33.804
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-28 13:28:33.804
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16b2d182,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79f3f34c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-09-28 13:28:42.611
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 2 0 2020-09-28 13:29:25.471
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-09-28 13:29:25.471
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:07.920
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:07.925
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@69b974a2[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:07.939
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:08.179
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.111
!MESSAGE Boot LS startup time from start to initialized: 3143ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.403
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.DcrcbTwpisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.410
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.415
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.422
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.429
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.435
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.440
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.446
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.DcrcbTwp => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.453
!MESSAGE classpath=1 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.461
!MESSAGE buffering callback sts4.classpath.DcrcbTwp ITSK_SmartMobility false 1

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.465
!MESSAGE executing callback sts4.classpath.DcrcbTwp 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:30:11.483
!MESSAGE executing callback sts4.classpath.DcrcbTwp SUCCESS [done]

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:18.271
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:19.271
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:51.809
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:52.810
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:53.785
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:54.895
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:55.845
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:56.878
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 2 0 2020-09-28 13:31:57.904
!MESSAGE Failed to dispatch repository event to org.eclipse.m2e.core.internal.embedder.EclipseRepositoryListener: null

!ENTRY org.eclipse.m2e.logback.appender 4 0 2020-09-28 13:33:42.581
!MESSAGE Could not download sources for org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.0
!STACK 1
org.eclipse.core.runtime.CoreException: Could not resolve artifact org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:sources:2.1.0
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.lambda$4(MavenImpl.java:803)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:179)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:114)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:101)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:771)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:748)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.download(DownloadSourcesJob.java:330)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadAttachments(DownloadSourcesJob.java:304)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadMaven(DownloadSourcesJob.java:269)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadFilesAndPopulateToUpdate(DownloadSourcesJob.java:233)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.lambda$0(DownloadSourcesJob.java:161)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:179)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:153)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:101)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:1373)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.run(DownloadSourcesJob.java:161)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Missing org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:sources:2.1.0
!SUBENTRY 1 org.eclipse.m2e.core 4 -1 2020-09-28 13:33:42.581
!MESSAGE Could not resolve artifact org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:sources:2.1.0
!SUBENTRY 2 org.eclipse.m2e.core 4 -1 2020-09-28 13:33:42.581
!MESSAGE Missing org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:sources:2.1.0

!ENTRY org.eclipse.ui 2 2 2020-09-28 13:33:56.152
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:35:02.706
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:35:02.718
!MESSAGE classpath=19 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:35:02.730
!MESSAGE buffering callback sts4.classpath.DcrcbTwp ITSK_SmartMobility false 19

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:35:02.738
!MESSAGE executing callback sts4.classpath.DcrcbTwp 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:35:02.751
!MESSAGE executing callback sts4.classpath.DcrcbTwp SUCCESS [done]

!ENTRY org.eclipse.m2e.logback.appender 4 0 2020-09-28 13:35:33.008
!MESSAGE Could not download javadoc for org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.0
!STACK 1
org.eclipse.core.runtime.CoreException: Could not resolve artifact org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:javadoc:2.1.0
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.lambda$4(MavenImpl.java:803)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:179)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:114)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:101)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:771)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.resolve(MavenImpl.java:748)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.download(DownloadSourcesJob.java:330)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadAttachments(DownloadSourcesJob.java:316)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadMaven(DownloadSourcesJob.java:269)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.downloadFilesAndPopulateToUpdate(DownloadSourcesJob.java:233)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.lambda$0(DownloadSourcesJob.java:161)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.executeBare(MavenExecutionContext.java:179)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:153)
	at org.eclipse.m2e.core.internal.embedder.MavenExecutionContext.execute(MavenExecutionContext.java:101)
	at org.eclipse.m2e.core.internal.embedder.MavenImpl.execute(MavenImpl.java:1373)
	at org.eclipse.m2e.jdt.internal.DownloadSourcesJob.run(DownloadSourcesJob.java:161)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Contains: Missing org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:javadoc:2.1.0
!SUBENTRY 1 org.eclipse.m2e.core 4 -1 2020-09-28 13:35:33.008
!MESSAGE Could not resolve artifact org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:javadoc:2.1.0
!SUBENTRY 2 org.eclipse.m2e.core 4 -1 2020-09-28 13:35:33.008
!MESSAGE Missing org.mybatis.spring.boot:mybatis-spring-boot-starter:jar:javadoc:2.1.0

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:36:19.190
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:36:19.202
!MESSAGE classpath=19 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:36:19.213
!MESSAGE buffering callback sts4.classpath.DcrcbTwp ITSK_SmartMobility false 19

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:36:19.223
!MESSAGE executing callback sts4.classpath.DcrcbTwp 1 batched events

!ENTRY org.eclipse.jdt.core 4 964 2020-09-28 13:36:19.234
!MESSAGE Cannot nest 'ITSK_SmartMobility/src/main/resources' inside 'ITSK_SmartMobility/src'. To enable the nesting exclude 'main/' from 'ITSK_SmartMobility/src'

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:36:19.254
!MESSAGE executing callback sts4.classpath.DcrcbTwp SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:37:06.430
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.eclipse.jdt.core 4 964 2020-09-28 13:37:06.442
!MESSAGE Cannot nest 'ITSK_SmartMobility/src/main/resources' inside 'ITSK_SmartMobility/src'. To enable the nesting exclude 'main/' from 'ITSK_SmartMobility/src'

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:37:06.451
!MESSAGE classpath=19 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:37:06.462
!MESSAGE buffering callback sts4.classpath.DcrcbTwp ITSK_SmartMobility false 19

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:37:06.470
!MESSAGE executing callback sts4.classpath.DcrcbTwp 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:37:06.483
!MESSAGE executing callback sts4.classpath.DcrcbTwp SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:00.436
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:00.445
!MESSAGE classpath=21 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:00.454
!MESSAGE buffering callback sts4.classpath.DcrcbTwp ITSK_SmartMobility false 21

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:00.461
!MESSAGE executing callback sts4.classpath.DcrcbTwp 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:00.470
!MESSAGE executing callback sts4.classpath.DcrcbTwp SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.006
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.020
!MESSAGE classpath=21 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.028
!MESSAGE buffering callback sts4.classpath.DcrcbTwp ITSK_SmartMobility false 21

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.036
!MESSAGE executing callback sts4.classpath.DcrcbTwp 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.045
!MESSAGE executing callback sts4.classpath.DcrcbTwp SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.660
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.687
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.720
!MESSAGE buffering callback sts4.classpath.DcrcbTwp ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.731
!MESSAGE executing callback sts4.classpath.DcrcbTwp 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:38:27.756
!MESSAGE executing callback sts4.classpath.DcrcbTwp SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:05.046
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.DcrcbTwp

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:05.051
!MESSAGE unsubscribing from classpath changes: sts4.classpath.DcrcbTwp

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:05.057
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:05.063
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.DcrcbTwp => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:08.179
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:08.185
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@69b974a2[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:08.189
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.068
!MESSAGE Boot LS startup time from start to initialized: 1871ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.095
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.sMXZJHzoisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.100
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.105
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.110
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.117
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.124
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.132
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.139
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.sMXZJHzo => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.147
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.160
!MESSAGE buffering callback sts4.classpath.sMXZJHzo ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.166
!MESSAGE executing callback sts4.classpath.sMXZJHzo 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.193
!MESSAGE executing callback sts4.classpath.sMXZJHzo SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.365
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.sMXZJHzo

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.371
!MESSAGE unsubscribing from classpath changes: sts4.classpath.sMXZJHzo

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.376
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 13:39:10.382
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.sMXZJHzo => OK

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.702
!MESSAGE No line style provider for org.eclipse.wst.sse.ST_DEFAULT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.710
!MESSAGE No line style provider for org.eclipse.wst.sse.UNKNOWN_PARTITION_TYPE

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.718
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_DEFAULT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.725
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_CDATA

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.738
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_DECL

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.745
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_COMMENT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.753
!MESSAGE No line style provider for org.eclipse.wst.xml.dtd.internal_subset

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.760
!MESSAGE No line style provider for org.eclipse.wst.xml.PROCESSING_INSTRUCTION:

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.768
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-09-28 15:31:26.776
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT.EVENTHANDLER

!ENTRY org.eclipse.jface 2 0 2020-09-28 15:35:05.617
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-09-28 15:35:05.617
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56e52961,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@408a8f4f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:02.045
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:02.052
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@69b974a2[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:02.056
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.191
!MESSAGE Boot LS startup time from start to initialized: 2129ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.223
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.sfeSHPBEisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.228
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.234
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.239
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.246
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.252
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.260
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.264
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.sfeSHPBE => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.280
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.290
!MESSAGE buffering callback sts4.classpath.sfeSHPBE ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.295
!MESSAGE executing callback sts4.classpath.sfeSHPBE 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 16:08:04.324
!MESSAGE executing callback sts4.classpath.sfeSHPBE SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 18:02:46.575
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.sfeSHPBE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 18:02:46.580
!MESSAGE unsubscribing from classpath changes: sts4.classpath.sfeSHPBE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 18:02:46.587
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-09-28 18:02:46.592
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.sfeSHPBE => OK
!SESSION 2020-10-05 09:02:11.321 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-05 09:02:22.004
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-05 09:02:22.004
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-05 09:02:25.833
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-05 09:02:25.833
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@238a7e3d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ed5cc8c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:39.040
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:39.045
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@6cf2b638[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:39.059
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:39.250
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:41.998
!MESSAGE Boot LS startup time from start to initialized: 2923ms

!ENTRY org.eclipse.egit.ui 2 0 2020-10-05 09:02:42.132
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.547
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.JkTphJkQisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.567
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.584
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.592
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.602
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.609
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.619
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.JkTphJkQ => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.628
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.680
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.696
!MESSAGE buffering callback sts4.classpath.JkTphJkQ ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.702
!MESSAGE executing callback sts4.classpath.JkTphJkQ 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 09:02:42.749
!MESSAGE executing callback sts4.classpath.JkTphJkQ SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 18:19:24.639
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.JkTphJkQ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 18:19:24.686
!MESSAGE unsubscribing from classpath changes: sts4.classpath.JkTphJkQ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 18:19:24.692
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-05 18:19:24.698
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.JkTphJkQ => OK

!ENTRY org.eclipse.ui 2 2 2020-10-05 18:19:25.235
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-06 10:27:31.126 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-06 10:27:40.865
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-06 10:27:40.865
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-06 10:27:44.365
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-06 10:27:44.365
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67aaf882,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6efc9d3f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:27:57.338
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:27:57.343
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1c32c581[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:27:57.357
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:27:57.513
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-06 10:28:00.549
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.336
!MESSAGE Boot LS startup time from start to initialized: 3948ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.795
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.LahdLmlqisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.807
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.815
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.825
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.832
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.842
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.849
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.858
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.LahdLmlq => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.889
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.902
!MESSAGE buffering callback sts4.classpath.LahdLmlq ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.906
!MESSAGE executing callback sts4.classpath.LahdLmlq 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 10:28:01.939
!MESSAGE executing callback sts4.classpath.LahdLmlq SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 18:03:33.839
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.LahdLmlq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 18:03:33.844
!MESSAGE unsubscribing from classpath changes: sts4.classpath.LahdLmlq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 18:03:33.849
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-06 18:03:33.854
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.LahdLmlq => OK

!ENTRY org.eclipse.ui 2 2 2020-10-06 18:03:34.502
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-08 11:40:32.635 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-08 11:40:51.042
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-08 11:40:51.042
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-08 11:40:54.873
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-08 11:40:54.873
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@374bf34b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67aaf882,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:09.378
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:09.383
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1a35f99a[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:09.396
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:09.593
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:13.428
!MESSAGE Boot LS startup time from start to initialized: 4002ms

!ENTRY org.eclipse.egit.ui 2 0 2020-10-08 11:41:13.471
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.202
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.BDRECOxhisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.214
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.229
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.238
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.246
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.253
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.257
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.262
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.BDRECOxh => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.295
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.310
!MESSAGE buffering callback sts4.classpath.BDRECOxh ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.316
!MESSAGE executing callback sts4.classpath.BDRECOxh 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 11:41:14.356
!MESSAGE executing callback sts4.classpath.BDRECOxh SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 17:27:49.452
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.BDRECOxh

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 17:27:49.462
!MESSAGE unsubscribing from classpath changes: sts4.classpath.BDRECOxh

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 17:27:49.469
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-08 17:27:49.476
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.BDRECOxh => OK

!ENTRY org.eclipse.ui 2 2 2020-10-08 17:27:50.122
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-12 09:17:42.211 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-12 09:17:56.688
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-12 09:17:56.688
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-12 09:18:00.191
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-12 09:18:00.191
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67aaf882,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6efc9d3f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:13.254
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:13.260
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1c32c581[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:13.273
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:13.471
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.295
!MESSAGE Boot LS startup time from start to initialized: 2992ms

!ENTRY org.eclipse.egit.ui 2 0 2020-10-12 09:18:16.389
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.799
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.wvPrraLzisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.812
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.835
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.851
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.863
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.876
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.886
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.904
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.wvPrraLz => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.926
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.940
!MESSAGE buffering callback sts4.classpath.wvPrraLz ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.947
!MESSAGE executing callback sts4.classpath.wvPrraLz 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 09:18:16.995
!MESSAGE executing callback sts4.classpath.wvPrraLz SUCCESS [done]

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.462
!MESSAGE No line style provider for org.eclipse.wst.sse.ST_DEFAULT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.467
!MESSAGE No line style provider for org.eclipse.wst.sse.UNKNOWN_PARTITION_TYPE

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.473
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_DEFAULT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.478
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_CDATA

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.485
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_DECL

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.491
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_COMMENT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.495
!MESSAGE No line style provider for org.eclipse.wst.xml.dtd.internal_subset

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.501
!MESSAGE No line style provider for org.eclipse.wst.xml.PROCESSING_INSTRUCTION:

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.506
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-10-12 09:19:15.515
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT.EVENTHANDLER

!ENTRY org.eclipse.jface 2 0 2020-10-12 09:20:38.525
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-12 09:20:38.525
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1443f11c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2b050bc3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.eclipse.ui 4 0 2020-10-12 09:20:42.190
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4723)
	at org.eclipse.swt.SWT.error(SWT.java:4638)
	at org.eclipse.swt.SWT.error(SWT.java:4609)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:432)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:351)
	at org.eclipse.swt.widgets.Tree.getSelection(Tree.java:3436)
	at org.eclipse.jface.viewers.TreeViewer.getSelection(TreeViewer.java:231)
	at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:308)
	at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:2564)
	at org.eclipse.ui.navigator.CommonViewer.setSelectionToWidget(CommonViewer.java:442)
	at org.eclipse.jface.viewers.AbstractTreeViewer.setSelectionToWidget(AbstractTreeViewer.java:3020)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1407)
	at org.eclipse.jface.viewers.TreeViewer.preservingSelection(TreeViewer.java:363)
	at org.eclipse.jface.viewers.StructuredViewer.preservingSelection(StructuredViewer.java:1361)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1484)
	at org.eclipse.jface.viewers.ColumnViewer.refresh(ColumnViewer.java:538)
	at org.eclipse.ui.navigator.CommonViewer.refresh(CommonViewer.java:352)
	at org.eclipse.ui.navigator.CommonViewer.refresh(CommonViewer.java:495)
	at org.eclipse.jface.viewers.StructuredViewer.refresh(StructuredViewer.java:1420)
	at org.eclipse.lsp4e.outline.LSSymbolsContentProvider.lambda$1(LSSymbolsContentProvider.java:262)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4005)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3633)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.ui 4 0 2020-10-12 09:20:42.196
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.NullPointerException
	at org.eclipse.lsp4e.outline.CNFOutlinePage.refreshTreeSelection(CNFOutlinePage.java:195)
	at org.eclipse.lsp4e.outline.LSSymbolsContentProvider.lambda$2(LSSymbolsContentProvider.java:273)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4005)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3633)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-12 10:05:54.404
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 18:20:44.685
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.wvPrraLz

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 18:20:44.693
!MESSAGE unsubscribing from classpath changes: sts4.classpath.wvPrraLz

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 18:20:44.700
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-12 18:20:44.706
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.wvPrraLz => OK

!ENTRY org.eclipse.ui 2 2 2020-10-12 18:20:45.288
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-13 13:40:17.765 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-13 13:40:26.720
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-13 13:40:26.720
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-13 13:40:30.292
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-13 13:40:30.292
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@294a12b5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@628aea61,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:44.991
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:44.998
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@449be249[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:45.014
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:45.204
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-13 13:40:48.050
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.227
!MESSAGE Boot LS startup time from start to initialized: 5176ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.645
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.SDcpzJNwisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.652
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.659
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.667
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.676
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.683
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.696
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.701
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.SDcpzJNw => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.719
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.731
!MESSAGE buffering callback sts4.classpath.SDcpzJNw ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.736
!MESSAGE executing callback sts4.classpath.SDcpzJNw 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 13:40:50.773
!MESSAGE executing callback sts4.classpath.SDcpzJNw SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-13 18:12:00.874
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 18:15:26.302
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.SDcpzJNw

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 18:15:26.307
!MESSAGE unsubscribing from classpath changes: sts4.classpath.SDcpzJNw

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 18:15:26.313
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-13 18:15:26.318
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.SDcpzJNw => OK

!ENTRY org.eclipse.ui 2 2 2020-10-13 18:15:26.945
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-14 09:10:38.579 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-14 09:11:02.189
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-14 09:11:02.189
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-14 09:11:05.680
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-14 09:11:05.680
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@a74c940,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66576bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:19.097
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:19.103
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@10101a10[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:19.117
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:19.324
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-14 09:11:21.916
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.150
!MESSAGE Boot LS startup time from start to initialized: 3003ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.837
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.OXEpBVVwisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.845
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.853
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.862
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.877
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.884
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.889
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.895
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.OXEpBVVw => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.919
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.932
!MESSAGE buffering callback sts4.classpath.OXEpBVVw ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.939
!MESSAGE executing callback sts4.classpath.OXEpBVVw 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 09:11:22.977
!MESSAGE executing callback sts4.classpath.OXEpBVVw SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-14 11:06:04.148
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2020-10-14 15:46:13.856
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-14 15:48:03.256
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 17:59:12.485
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.OXEpBVVw

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 17:59:12.492
!MESSAGE unsubscribing from classpath changes: sts4.classpath.OXEpBVVw

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 17:59:12.498
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-14 17:59:12.504
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.OXEpBVVw => OK
!SESSION 2020-10-15 08:59:27.738 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-15 08:59:33.044
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-15 08:59:33.044
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-15 08:59:34.949
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-15 08:59:34.949
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@109188b4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7091a016,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:44.712
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:44.717
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@3d1b97e4[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:44.725
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:44.765
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-15 08:59:47.362
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:48.821
!MESSAGE Boot LS startup time from start to initialized: 4078ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.156
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.GByEwNDXisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.165
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.172
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.180
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.188
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.208
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.213
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.217
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.GByEwNDX => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.235
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.245
!MESSAGE buffering callback sts4.classpath.GByEwNDX ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.250
!MESSAGE executing callback sts4.classpath.GByEwNDX 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 08:59:49.283
!MESSAGE executing callback sts4.classpath.GByEwNDX SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 20:48:07.429
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.GByEwNDX

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 20:48:07.477
!MESSAGE unsubscribing from classpath changes: sts4.classpath.GByEwNDX

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 20:48:07.483
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-15 20:48:07.488
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.GByEwNDX => OK

!ENTRY org.eclipse.ui 2 2 2020-10-15 20:48:08.185
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-19 08:55:19.921 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-19 08:55:28.049
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-19 08:55:28.049
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-19 08:55:31.661
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-19 08:55:31.661
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3f2a7ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@23e297d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:45.279
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:45.284
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@3d1b97e4[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:45.296
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:45.446
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-19 08:55:47.545
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.410
!MESSAGE Boot LS startup time from start to initialized: 4092ms

!ENTRY org.eclipse.lsp4e 4 0 2020-10-19 08:55:49.839
!MESSAGE org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
!STACK 0
java.util.concurrent.ExecutionException: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.lambda$12(LSPTextHover.java:271)
	at java.util.stream.ReferencePipeline$3$1.accept(Unknown Source)
	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(Unknown Source)
	at java.util.stream.AbstractPipeline.copyInto(Unknown Source)
	at java.util.stream.AbstractPipeline.wrapAndCopyInto(Unknown Source)
	at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(Unknown Source)
	at java.util.stream.AbstractPipeline.evaluate(Unknown Source)
	at java.util.stream.ReferencePipeline.collect(Unknown Source)
	at org.eclipse.lsp4e.operations.hover.LSPTextHover.lambda$11(LSPTextHover.java:280)
	at java.util.concurrent.CompletableFuture.uniApply(Unknown Source)
	at java.util.concurrent.CompletableFuture$UniApply.tryFire(Unknown Source)
	at java.util.concurrent.CompletableFuture$Completion.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)
Caused by: org.eclipse.lsp4j.jsonrpc.ResponseErrorException: Internal error.
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleResponse(RemoteEndpoint.java:209)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:193)
	at org.eclipse.lsp4e.LanguageServerWrapper.lambda$2(LanguageServerWrapper.java:251)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source)
	at java.util.concurrent.FutureTask.run(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)
	at java.lang.Thread.run(Unknown Source)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.848
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.lAaUdiPfisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.877
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.891
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.917
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.934
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.943
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.950
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.957
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.lAaUdiPf => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:49.992
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:50.004
!MESSAGE buffering callback sts4.classpath.lAaUdiPf ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:50.009
!MESSAGE executing callback sts4.classpath.lAaUdiPf 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 08:55:50.063
!MESSAGE executing callback sts4.classpath.lAaUdiPf SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-19 08:55:50.339
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.util.concurrent.CompletableFuture.timedGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-19 15:16:45.575
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-19 16:31:45.757
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-19 16:33:45.983
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.util.concurrent.CompletableFuture.timedGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-19 16:38:26.574
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 18:28:28.201
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.lAaUdiPf

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 18:28:28.220
!MESSAGE unsubscribing from classpath changes: sts4.classpath.lAaUdiPf

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 18:28:28.226
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-19 18:28:28.231
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.lAaUdiPf => OK

!ENTRY org.eclipse.ui 2 2 2020-10-19 18:28:28.711
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-20 08:58:32.817 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-20 08:58:40.332
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-20 08:58:40.332
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-20 08:58:44.081
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-20 08:58:44.081
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66576bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@51bc649e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:58:58.238
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:58:58.243
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7fbb3144[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:58:58.257
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:58:58.403
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-20 08:59:01.403
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.237
!MESSAGE Boot LS startup time from start to initialized: 3958ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.650
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.FRLBroMnisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.659
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.666
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.676
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.685
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.693
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.701
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.708
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.FRLBroMn => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.742
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.756
!MESSAGE buffering callback sts4.classpath.FRLBroMn ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.761
!MESSAGE executing callback sts4.classpath.FRLBroMn 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 08:59:02.797
!MESSAGE executing callback sts4.classpath.FRLBroMn SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-10-20 15:51:57.730
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 18:28:31.752
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.FRLBroMn

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 18:28:31.771
!MESSAGE unsubscribing from classpath changes: sts4.classpath.FRLBroMn

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 18:28:31.777
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-20 18:28:31.782
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.FRLBroMn => OK
!SESSION 2020-10-21 09:05:03.066 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-21 09:05:21.931
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-21 09:05:21.932
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-21 09:05:25.539
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-21 09:05:25.539
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66576bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@51bc649e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:40.805
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:40.810
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@c5ed57e[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:40.824
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:40.992
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-21 09:05:43.921
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:45.899
!MESSAGE Boot LS startup time from start to initialized: 5054ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.383
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.uZMWaMxPisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.396
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.408
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.425
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.435
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.441
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.448
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.454
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.uZMWaMxP => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.489
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.502
!MESSAGE buffering callback sts4.classpath.uZMWaMxP ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.509
!MESSAGE executing callback sts4.classpath.uZMWaMxP 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 09:05:46.548
!MESSAGE executing callback sts4.classpath.uZMWaMxP SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-21 11:57:15.884
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-21 13:11:26.325
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 14:43:53.087
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.uZMWaMxP

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 14:43:53.125
!MESSAGE unsubscribing from classpath changes: sts4.classpath.uZMWaMxP

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 14:43:53.131
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 14:43:53.138
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.uZMWaMxP => OK

!ENTRY org.eclipse.ui 2 2 2020-10-21 14:43:53.725
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-21 14:59:57.338 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-21 15:00:04.227
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-21 15:00:04.227
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-21 15:00:07.825
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-21 15:00:07.825
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66576bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@51bc649e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-10-21 15:00:23.629
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:25.267
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:25.276
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@40a43556[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:25.308
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:25.608
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:29.634
!MESSAGE Boot LS startup time from start to initialized: 4298ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.104
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.plFtEmMdisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.113
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.122
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.130
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.141
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.148
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.156
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.163
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.plFtEmMd => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.199
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.217
!MESSAGE buffering callback sts4.classpath.plFtEmMd ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.236
!MESSAGE executing callback sts4.classpath.plFtEmMd 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 15:00:30.745
!MESSAGE executing callback sts4.classpath.plFtEmMd SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 18:18:47.848
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.plFtEmMd

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 18:18:47.856
!MESSAGE unsubscribing from classpath changes: sts4.classpath.plFtEmMd

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 18:18:47.861
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-21 18:18:47.868
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.plFtEmMd => OK

!ENTRY org.eclipse.ui 2 2 2020-10-21 18:18:48.427
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-22 09:13:01.897 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-22 09:13:09.115
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-22 09:13:09.115
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-22 09:13:13.030
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-22 09:13:13.030
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f09ff10,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@531b1778,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:28.675
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:28.682
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7bfb46b2[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:28.698
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:28.876
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-22 09:13:32.432
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:33.771
!MESSAGE Boot LS startup time from start to initialized: 5054ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.255
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.TQBMHcSxisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.265
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.284
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.300
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.312
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.335
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.343
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.348
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.TQBMHcSx => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.372
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.389
!MESSAGE buffering callback sts4.classpath.TQBMHcSx ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.395
!MESSAGE executing callback sts4.classpath.TQBMHcSx 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 09:13:34.436
!MESSAGE executing callback sts4.classpath.TQBMHcSx SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 18:07:48.976
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.TQBMHcSx

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 18:07:48.993
!MESSAGE unsubscribing from classpath changes: sts4.classpath.TQBMHcSx

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 18:07:48.999
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-22 18:07:49.004
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.TQBMHcSx => OK

!ENTRY org.eclipse.ui 2 2 2020-10-22 18:07:49.740
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-23 08:52:54.584 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-23 08:53:02.038
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-23 08:53:02.038
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-23 08:53:05.660
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-23 08:53:05.660
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@a74c940,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66576bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-10-23 08:53:18.000
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:44.490
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:44.497
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7075ef91[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:44.515
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:44.726
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.ui 2 2 2020-10-23 09:07:49.036
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.086
!MESSAGE Boot LS startup time from start to initialized: 4551ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.522
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.YjfhLAbsisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.532
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.543
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.552
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.561
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.572
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.578
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.583
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.YjfhLAbs => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.611
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.649
!MESSAGE buffering callback sts4.classpath.YjfhLAbs ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.672
!MESSAGE executing callback sts4.classpath.YjfhLAbs 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:49.729
!MESSAGE executing callback sts4.classpath.YjfhLAbs SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:58.931
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.YjfhLAbs

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:58.963
!MESSAGE unsubscribing from classpath changes: sts4.classpath.YjfhLAbs

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:58.970
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:07:58.978
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.YjfhLAbs => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:00.232
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:00.239
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7075ef91[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:00.258
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.825
!MESSAGE Boot LS startup time from start to initialized: 3523ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.859
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.VLbQUVMLisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.887
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.924
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.931
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.943
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.952
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.957
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.963
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.VLbQUVML => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.972
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.984
!MESSAGE buffering callback sts4.classpath.VLbQUVML ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:03.988
!MESSAGE executing callback sts4.classpath.VLbQUVML 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 09:08:04.021
!MESSAGE executing callback sts4.classpath.VLbQUVML SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 17:31:36.884
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.VLbQUVML

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 17:31:36.912
!MESSAGE unsubscribing from classpath changes: sts4.classpath.VLbQUVML

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 17:31:36.919
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-23 17:31:36.925
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.VLbQUVML => OK
!SESSION 2020-10-26 08:49:26.463 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-26 08:50:09.902
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-26 08:50:09.902
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-26 08:50:13.265
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-26 08:50:13.265
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66576bd2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@51bc649e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:26.090
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:26.099
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@32e14e55[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:26.132
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:26.216
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-26 08:50:29.137
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.332
!MESSAGE Boot LS startup time from start to initialized: 5168ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.760
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.TCtSbrrCisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.770
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.777
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.784
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.791
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.798
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.804
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.852
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.TCtSbrrC => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.883
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.895
!MESSAGE buffering callback sts4.classpath.TCtSbrrC ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.901
!MESSAGE executing callback sts4.classpath.TCtSbrrC 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 08:50:31.940
!MESSAGE executing callback sts4.classpath.TCtSbrrC SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:45.299
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.TCtSbrrC

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:45.305
!MESSAGE unsubscribing from classpath changes: sts4.classpath.TCtSbrrC

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:45.311
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:45.318
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.TCtSbrrC => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:46.885
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:46.890
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@32e14e55[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:46.898
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.876
!MESSAGE Boot LS startup time from start to initialized: 1972ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.920
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.LavJOcKiisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.927
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.936
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.944
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.956
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.989
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:48.997
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:49.004
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.LavJOcKi => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:49.017
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:49.030
!MESSAGE buffering callback sts4.classpath.LavJOcKi ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:49.037
!MESSAGE executing callback sts4.classpath.LavJOcKi 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 14:07:49.068
!MESSAGE executing callback sts4.classpath.LavJOcKi SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-26 14:28:13.263
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-26 17:14:38.127
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-26 17:47:09.454
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-26 17:57:22.201
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 18:05:39.745
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.LavJOcKi

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 18:05:39.751
!MESSAGE unsubscribing from classpath changes: sts4.classpath.LavJOcKi

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 18:05:39.757
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-26 18:05:39.762
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.LavJOcKi => OK

!ENTRY org.eclipse.ui 2 2 2020-10-26 18:05:40.355
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-27 08:50:47.119 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-27 08:50:55.323
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-27 08:50:55.323
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-27 08:50:58.664
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-27 08:50:58.664
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7091a016,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14580edc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:10.955
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:10.960
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@e124366[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:10.975
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:11.042
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-27 08:51:13.859
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:14.889
!MESSAGE Boot LS startup time from start to initialized: 3882ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.340
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.wdXbQMWYisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.349
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.358
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.366
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.376
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.420
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.426
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.431
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.wdXbQMWY => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.451
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.465
!MESSAGE buffering callback sts4.classpath.wdXbQMWY ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.478
!MESSAGE executing callback sts4.classpath.wdXbQMWY 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 08:51:15.520
!MESSAGE executing callback sts4.classpath.wdXbQMWY SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-27 16:25:23.975
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-27 16:45:06.789
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-27 17:07:20.736
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:43:11.901
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.wdXbQMWY

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:43:11.908
!MESSAGE unsubscribing from classpath changes: sts4.classpath.wdXbQMWY

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:43:11.916
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:43:11.922
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.wdXbQMWY => OK

!ENTRY org.eclipse.ui 2 2 2020-10-27 18:43:12.541
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-27 18:46:18.311 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-27 18:46:27.717
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-27 18:46:27.717
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-27 18:46:32.480
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-27 18:46:32.480
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3f2a7ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@23e297d9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:46.886
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:46.891
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@4c44928e[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:46.904
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:47.069
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-27 18:46:49.264
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.168
!MESSAGE Boot LS startup time from start to initialized: 4245ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.541
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ILqwRYOmisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.549
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.557
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.568
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.579
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.590
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.638
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.643
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ILqwRYOm => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.681
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.695
!MESSAGE buffering callback sts4.classpath.ILqwRYOm ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.701
!MESSAGE executing callback sts4.classpath.ILqwRYOm 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 18:46:51.738
!MESSAGE executing callback sts4.classpath.ILqwRYOm SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-27 18:54:39.508
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-27 19:14:32.613
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 20:30:21.425
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ILqwRYOm

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 20:30:21.431
!MESSAGE unsubscribing from classpath changes: sts4.classpath.ILqwRYOm

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 20:30:21.437
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-27 20:30:21.442
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ILqwRYOm => OK

!ENTRY org.eclipse.ui 2 2 2020-10-27 20:30:22.038
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-28 08:52:12.502 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-28 08:53:28.870
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-28 08:53:28.870
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-28 08:53:32.537
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-28 08:53:32.537
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14580edc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3f2a7ca0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:46.183
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:46.188
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@63d93e91[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:46.202
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:46.350
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-28 08:53:49.126
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:50.603
!MESSAGE Boot LS startup time from start to initialized: 4380ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:50.995
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.RrUWcvaeisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.004
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.011
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.019
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.054
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.060
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.067
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.073
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.RrUWcvae => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.092
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.105
!MESSAGE buffering callback sts4.classpath.RrUWcvae ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.109
!MESSAGE executing callback sts4.classpath.RrUWcvae 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 08:53:51.147
!MESSAGE executing callback sts4.classpath.RrUWcvae SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-28 11:37:15.924
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-28 12:59:58.776
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-28 13:00:23.495
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 18:31:10.941
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.RrUWcvae

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 18:31:10.988
!MESSAGE unsubscribing from classpath changes: sts4.classpath.RrUWcvae

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 18:31:10.993
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-28 18:31:10.999
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.RrUWcvae => OK

!ENTRY org.eclipse.ui 2 2 2020-10-28 18:31:11.698
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-29 08:50:30.048 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-29 08:50:44.462
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-29 08:50:44.462
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-29 08:50:48.543
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-29 08:50:48.543
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7091a016,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@14580edc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:03.703
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:03.707
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@4eb3dacc[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:03.723
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:03.874
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-29 08:51:06.665
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:07.725
!MESSAGE Boot LS startup time from start to initialized: 3981ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.159
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.BfnUGpmkisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.167
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.175
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.183
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.194
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.206
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.213
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.221
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.BfnUGpmk => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.271
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.305
!MESSAGE buffering callback sts4.classpath.BfnUGpmk ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.311
!MESSAGE executing callback sts4.classpath.BfnUGpmk 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 08:51:08.351
!MESSAGE executing callback sts4.classpath.BfnUGpmk SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 16:19:30.778
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 16:32:57.082
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 16:58:16.224
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 17:50:19.638
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.BfnUGpmk

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 17:50:19.644
!MESSAGE unsubscribing from classpath changes: sts4.classpath.BfnUGpmk

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 17:50:19.657
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 17:50:19.662
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.BfnUGpmk => OK

!ENTRY org.eclipse.ui 2 2 2020-10-29 17:50:20.446
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-29 19:42:53.664 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-29 19:43:00.333
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-29 19:43:00.333
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-29 19:43:03.152
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-29 19:43:03.152
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@109188b4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7091a016,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:14.573
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:14.580
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1b33bbbe[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:14.593
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:14.624
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:17.753
!MESSAGE Boot LS startup time from start to initialized: 3145ms

!ENTRY org.eclipse.egit.ui 2 0 2020-10-29 19:43:17.951
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.568
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ZhpFokWpisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.579
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.590
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.601
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.612
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.681
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.689
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.696
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ZhpFokWp => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.715
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.738
!MESSAGE buffering callback sts4.classpath.ZhpFokWp ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.753
!MESSAGE executing callback sts4.classpath.ZhpFokWp 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-29 19:43:18.818
!MESSAGE executing callback sts4.classpath.ZhpFokWp SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 21:12:10.450
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-29 22:39:53.935
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 22:41:03.208
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-29 22:46:16.947
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 22:46:17.085
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface 2 0 2020-10-29 22:49:20.642
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-29 22:49:20.642
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55a693b5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@662c4be7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 22:51:18.181
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-29 23:03:11.949
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-10-29 23:03:12.176
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-29 23:37:21.886
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-29 23:53:23.055
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 00:12:18.131
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 00:12:59.717
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 00:15:15.493
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 00:16:16.120
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 00:16:54.662
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:13:52.173
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 01:13:52.368
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:14:16.362
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:21:11.238
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:26:19.806
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:28:47.672
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:30:45.105
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:33:14.769
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 01:40:30.406
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-10-30 01:42:31.121
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 01:48:20.380
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 01:48:23.312
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 02:29:58.001
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ZhpFokWp

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 02:29:58.009
!MESSAGE unsubscribing from classpath changes: sts4.classpath.ZhpFokWp

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 02:29:58.017
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 02:29:58.023
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ZhpFokWp => OK

!ENTRY org.eclipse.ui 2 2 2020-10-30 02:29:58.659
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-30 08:58:45.101 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-30 08:58:51.137
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-30 08:58:51.137
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-30 08:58:53.432
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-30 08:58:53.432
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@781bd9dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1cc42abe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:03.420
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:03.427
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@51db8b10[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:03.438
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:03.530
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-30 08:59:07.029
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:07.489
!MESSAGE Boot LS startup time from start to initialized: 3990ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:07.924
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.DNLxxKQsisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:07.940
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:07.949
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:07.959
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:07.971
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:07.981
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:08.102
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:08.116
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.DNLxxKQs => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:08.128
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:08.141
!MESSAGE buffering callback sts4.classpath.DNLxxKQs ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:08.146
!MESSAGE executing callback sts4.classpath.DNLxxKQs 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 08:59:08.179
!MESSAGE executing callback sts4.classpath.DNLxxKQs SUCCESS [done]

!ENTRY org.eclipse.jdt.core 4 2 2020-10-30 09:50:07.871
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:169)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-10-30 09:50:07.895
!MESSAGE Exception occurred in listener of Java element change notification
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:169)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 09:57:12.574
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:30:34.098
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.DNLxxKQs

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:30:34.105
!MESSAGE unsubscribing from classpath changes: sts4.classpath.DNLxxKQs

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:30:34.113
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:30:34.122
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.DNLxxKQs => OK

!ENTRY org.eclipse.ui 2 2 2020-10-30 11:30:34.752
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-10-30 11:31:20.146 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-10-30 11:31:43.240
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-10-30 11:31:43.240
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-10-30 11:31:46.285
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-10-30 11:31:46.285
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1cc42abe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f071d0c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:31:56.906
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:31:56.911
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@5290b819[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:31:56.928
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:31:56.979
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-10-30 11:31:58.971
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.273
!MESSAGE Boot LS startup time from start to initialized: 3314ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.524
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.tNqXyfgSisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.531
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.538
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.546
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.556
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.563
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.583
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.587
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.tNqXyfgS => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.598
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.609
!MESSAGE buffering callback sts4.classpath.tNqXyfgS ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.615
!MESSAGE executing callback sts4.classpath.tNqXyfgS 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 11:32:00.645
!MESSAGE executing callback sts4.classpath.tNqXyfgS SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 13:22:06.262
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 13:35:56.229
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 13:40:13.400
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 14:11:19.784
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 14:19:53.910
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 14:32:56.481
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 14:45:29.510
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 14:53:35.418
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 14:57:44.456
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-10-30 14:57:47.045
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 17:26:04.569
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.tNqXyfgS

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 17:26:04.576
!MESSAGE unsubscribing from classpath changes: sts4.classpath.tNqXyfgS

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 17:26:04.584
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-10-30 17:26:04.590
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.tNqXyfgS => OK

!ENTRY org.eclipse.ui 2 2 2020-10-30 17:26:05.205
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-01 22:34:13.986 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-01 22:34:22.236
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-01 22:34:22.236
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-01 22:34:25.557
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-01 22:34:25.557
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@65a8c306,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@71ce19ee,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:39.834
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:39.840
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1eb85e83[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:39.852
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:40.021
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:42.826
!MESSAGE Boot LS startup time from start to initialized: 2960ms

!ENTRY org.eclipse.egit.ui 2 0 2020-11-01 22:34:42.873
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.347
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ZIBgYLZSisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.359
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.368
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.381
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.395
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.403
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.418
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.435
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ZIBgYLZS => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.483
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.503
!MESSAGE buffering callback sts4.classpath.ZIBgYLZS ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.510
!MESSAGE executing callback sts4.classpath.ZIBgYLZS 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-01 22:34:43.578
!MESSAGE executing callback sts4.classpath.ZIBgYLZS SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-02 01:05:21.709
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-02 09:42:36.504
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-02 11:00:43.694
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-02 11:15:09.317
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-02 11:36:04.903
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-02 14:51:43.102
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {
	
	//park
	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		
		//System.out.println(" input :"+input);
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		//0: , 1: , 2: 
		service.updateReserveScenario(input,0,srTemp); //  
		
		
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		
		
		//timer 
		Timer timer = new Timer();
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				
//				//      
//				for(int i=0; i<rsrvTimeArr.size();i++) {
//					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
//						rsrvTimeArr.remove(i);
//					}
//				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println(" ?? "+listTemp.get(j).get("reserveId"));
								//timer.cancel();
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							service.updateReserveScenario(input, 1, srTemp);// 
							System.out.println("  ");
							service.executeScenario(scenarioList);// ->   true
							service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							
						}
						
					}

				}
				//    false
				gExecuteFlag=false;
				//       
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String divRsrvList[]= rsrvList.get(i).split(",");
					
					
					if(Integer.parseInt(s)divRsrvList[1].-100 < System.currentTimeMillis() && rsrvList.get(i)+100 > System.currentTimeMillis()) {
						rsrvList.remove(i);
					}
				}
			}
			//input.put("sessionId", request.getSession().getId());
		};

		timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		
	

		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-02 14:51:43.259
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-02 14:51:43.266
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-02 14:51:43.297
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {
	
	//park
	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		
		//System.out.println(" input :"+input);
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		//0: , 1: , 2: 
		service.updateReserveScenario(input,0,srTemp); //  
		
		
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		
		
		//timer 
		Timer timer = new Timer();
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				
//				//      
//				for(int i=0; i<rsrvTimeArr.size();i++) {
//					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
//						rsrvTimeArr.remove(i);
//					}
//				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println(" ?? "+listTemp.get(j).get("reserveId"));
								//timer.cancel();
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							service.updateReserveScenario(input, 1, srTemp);// 
							System.out.println("  ");
							service.executeScenario(scenarioList);// ->   true
							service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							
						}
						
					}

				}
				//    false
				gExecuteFlag=false;
				//       
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String divRsrvList[]= rsrvList.get(i).split(",");
					
					
					if(Integer.parseInt(s)divRsrvList[1].-100 < System.currentTimeMillis() && rsrvList.get(i)+100 > System.currentTimeMillis()) {
						rsrvList.remove(i);
					}
				}
			}
			//input.put("sessionId", request.getSession().getId());
		};

		timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		
	

		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-02 14:51:43.332
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-02 14:51:43.337
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-02 14:51:45.077
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {
	
	//park
	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		
		//System.out.println(" input :"+input);
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		//0: , 1: , 2: 
		service.updateReserveScenario(input,0,srTemp); //  
		
		
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		
		
		//timer 
		Timer timer = new Timer();
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				
//				//      
//				for(int i=0; i<rsrvTimeArr.size();i++) {
//					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
//						rsrvTimeArr.remove(i);
//					}
//				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println(" ?? "+listTemp.get(j).get("reserveId"));
								//timer.cancel();
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							service.updateReserveScenario(input, 1, srTemp);// 
							System.out.println("  ");
							service.executeScenario(scenarioList);// ->   true
							service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							
						}
						
					}

				}
				//    false
				gExecuteFlag=false;
				//       
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String divRsrvList[]= rsrvList.get(i).split(",");
					
					
					if(Integer.parseInt(s)divRsrvList[1].-100 < System.currentTimeMillis() && rsrvList.get(i)+100 > System.currentTimeMillis()) {
						rsrvList.remove(i);
					}
				}
			}
			//input.put("sessionId", request.getSession().getId());
		};

		timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		
	

		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-02 14:51:45.103
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-02 14:51:45.108
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-02 14:51:45.655
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {
	
	//park
	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		
		//System.out.println(" input :"+input);
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		//0: , 1: , 2: 
		service.updateReserveScenario(input,0,srTemp); //  
		
		
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		
		
		//timer 
		Timer timer = new Timer();
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				
//				//      
//				for(int i=0; i<rsrvTimeArr.size();i++) {
//					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
//						rsrvTimeArr.remove(i);
//					}
//				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println(" ?? "+listTemp.get(j).get("reserveId"));
								//timer.cancel();
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							service.updateReserveScenario(input, 1, srTemp);// 
							System.out.println("  ");
							service.executeScenario(scenarioList);// ->   true
							service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							
						}
						
					}

				}
				//    false
				gExecuteFlag=false;
				//       
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String divRsrvList[]= rsrvList.get(i).split(",");
					
					
					if(Integer.parseInt(s)divRsrvList[1].-100 < System.currentTimeMillis() && rsrvList.get(i)+100 > System.currentTimeMillis()) {
						rsrvList.remove(i);
					}
				}
			}
			//input.put("sessionId", request.getSession().getId());
		};

		timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		
	

		
		return input;
	}
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor83.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-02 14:51:45.661
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor83.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-02 14:51:45.668
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3023)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2193)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2773)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationFragment(ASTConverter.java:3883)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToVariableDeclarationStatement(ASTConverter.java:3963)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleLocalDeclaration(ASTConverter.java:557)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:749)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor83.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-02 16:10:01.715
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jface 2 0 2020-11-02 16:10:32.113
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-02 16:10:32.113
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1a90f315,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1677a6a8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.eclipse.jface 2 0 2020-11-02 16:14:22.494
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-02 16:14:22.494
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec228c1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5d4244b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:47.388
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ZIBgYLZS

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:47.394
!MESSAGE unsubscribing from classpath changes: sts4.classpath.ZIBgYLZS

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:47.400
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:47.406
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ZIBgYLZS => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:48.673
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:48.678
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1eb85e83[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:48.683
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.556
!MESSAGE Boot LS startup time from start to initialized: 1868ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.587
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.sZBOHDfHisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.595
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.602
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.611
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.619
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.627
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.634
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.645
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.sZBOHDfH => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.656
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.668
!MESSAGE buffering callback sts4.classpath.sZBOHDfH ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.681
!MESSAGE executing callback sts4.classpath.sZBOHDfH 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 16:32:50.705
!MESSAGE executing callback sts4.classpath.sZBOHDfH SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 18:49:53.873
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.sZBOHDfH

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 18:49:53.884
!MESSAGE unsubscribing from classpath changes: sts4.classpath.sZBOHDfH

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 18:49:53.890
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 18:49:53.895
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.sZBOHDfH => OK

!ENTRY org.eclipse.ui 2 2 2020-11-02 18:49:54.510
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-02 20:44:44.291 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-02 20:44:52.034
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-02 20:44:52.034
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-02 20:44:55.410
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-02 20:44:55.410
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f071d0c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@138d978e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:06.998
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:07.003
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@5dac488d[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:07.016
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:07.178
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:09.635
!MESSAGE Boot LS startup time from start to initialized: 2589ms

!ENTRY org.eclipse.egit.ui 2 0 2020-11-02 20:45:09.797
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.026
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.jKdyOhhOisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.034
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.043
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.052
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.062
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.070
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.103
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.109
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.jKdyOhhO => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.127
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.140
!MESSAGE buffering callback sts4.classpath.jKdyOhhO ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.147
!MESSAGE executing callback sts4.classpath.jKdyOhhO 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-02 20:45:10.215
!MESSAGE executing callback sts4.classpath.jKdyOhhO SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-02 21:29:45.998
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-02 21:37:30.850
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-02 23:18:56.523
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jface 2 0 2020-11-02 23:19:34.819
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-02 23:19:34.819
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e0d3ea9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2eebb0ce,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-03 00:00:03.325
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 00:08:30.071
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.jKdyOhhO

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 00:08:30.078
!MESSAGE unsubscribing from classpath changes: sts4.classpath.jKdyOhhO

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 00:08:30.084
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 00:08:30.090
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.jKdyOhhO => OK

!ENTRY org.eclipse.ui 2 2 2020-11-03 00:08:30.841
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-03 08:44:31.210 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-03 08:44:54.661
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-03 08:44:54.661
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-03 08:44:56.519
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-03 08:44:56.519
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1cc42abe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f071d0c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:04.123
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:04.129
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7ee46aaf[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:04.136
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:04.229
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-03 08:45:06.916
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.339
!MESSAGE Boot LS startup time from start to initialized: 3144ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.711
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.GEQxPqfyisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.720
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.727
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.735
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.746
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.753
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.764
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.773
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.GEQxPqfy => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.804
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.818
!MESSAGE buffering callback sts4.classpath.GEQxPqfy ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.825
!MESSAGE executing callback sts4.classpath.GEQxPqfy 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 08:45:07.861
!MESSAGE executing callback sts4.classpath.GEQxPqfy SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 09:00:58.492
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.util.concurrent.CompletableFuture.timedGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 2 2020-11-03 09:09:40.339
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:169)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-03 09:09:40.348
!MESSAGE Exception occurred in listener of Java element change notification
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:169)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 09:16:33.350
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-03 09:21:20.379
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 13:36:35.930
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2020-11-03 14:05:51.869
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 14:55:59.200
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 15:03:10.178
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 15:32:46.598
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 15:42:07.156
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-03 15:46:16.284
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-03 16:34:18.656
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-03 16:35:46.547
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-03 16:36:40.268
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jface 2 0 2020-11-03 16:51:37.853
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-03 16:51:37.853
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7cf270f6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bf75830,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 18:45:56.031
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.GEQxPqfy

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 18:45:56.039
!MESSAGE unsubscribing from classpath changes: sts4.classpath.GEQxPqfy

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 18:45:56.046
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 18:45:56.052
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.GEQxPqfy => OK
!SESSION 2020-11-03 21:00:42.529 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-03 21:00:54.140
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-03 21:00:54.140
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-03 21:00:56.909
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-03 21:00:56.909
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f071d0c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@138d978e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:05.068
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:05.073
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@fcecc45[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:05.086
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:05.144
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:07.496
!MESSAGE Boot LS startup time from start to initialized: 2370ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:07.989
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.dkLJADQGisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.019
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.041
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.053
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.064
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.073
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.081
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.dkLJADQG => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.090
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.eclipse.egit.ui 2 0 2020-11-03 21:01:08.259
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.794
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.825
!MESSAGE buffering callback sts4.classpath.dkLJADQG ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.838
!MESSAGE executing callback sts4.classpath.dkLJADQG 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 21:01:08.883
!MESSAGE executing callback sts4.classpath.dkLJADQG SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-03 21:11:08.743
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 22:52:08.261
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.dkLJADQG

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 22:52:08.268
!MESSAGE unsubscribing from classpath changes: sts4.classpath.dkLJADQG

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 22:52:08.273
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-03 22:52:08.278
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.dkLJADQG => OK
!SESSION 2020-11-04 08:56:40.316 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-04 08:56:50.462
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-04 08:56:50.462
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-04 08:56:53.218
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-04 08:56:53.218
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@811d8d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f57a7a4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:02.574
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:02.582
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@28023029[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:02.595
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:02.696
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-04 08:57:06.523
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:07.698
!MESSAGE Boot LS startup time from start to initialized: 5032ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.094
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.YQgltwPqisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.103
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.110
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.119
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.130
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.140
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.150
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.167
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.YQgltwPq => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.217
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.237
!MESSAGE buffering callback sts4.classpath.YQgltwPq ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.246
!MESSAGE executing callback sts4.classpath.YQgltwPq 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 08:57:08.329
!MESSAGE executing callback sts4.classpath.YQgltwPq SUCCESS [done]

!ENTRY org.eclipse.jdt.core 4 2 2020-11-04 09:02:42.404
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2306)
	at org.eclipse.core.internal.events.NotificationManager$NotifyJob.run(NotificationManager.java:44)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-04 09:02:42.411
!MESSAGE Exception occurred in listener of Java element change notification
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2306)
	at org.eclipse.core.internal.events.NotificationManager$NotifyJob.run(NotificationManager.java:44)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 09:03:35.581
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 2 2020-11-04 09:11:42.692
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:169)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-04 09:11:42.698
!MESSAGE Exception occurred in listener of Java element change notification
!STACK 0
java.lang.NullPointerException
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:778)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.handleAffectedChildren(PackageExplorerContentProvider.java:820)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.processDelta(PackageExplorerContentProvider.java:763)
	at org.eclipse.jdt.internal.ui.packageview.PackageExplorerContentProvider.elementChanged(PackageExplorerContentProvider.java:139)
	at org.eclipse.jdt.internal.core.DeltaProcessor$3.run(DeltaProcessor.java:1755)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyListeners(DeltaProcessor.java:1743)
	at org.eclipse.jdt.internal.core.DeltaProcessor.firePostChangeDelta(DeltaProcessor.java:1576)
	at org.eclipse.jdt.internal.core.DeltaProcessor.fire(DeltaProcessor.java:1552)
	at org.eclipse.jdt.internal.core.DeltaProcessor.notifyAndFire(DeltaProcessor.java:2273)
	at org.eclipse.jdt.internal.core.DeltaProcessor.resourceChanged(DeltaProcessor.java:2163)
	at org.eclipse.jdt.internal.core.DeltaProcessingState.resourceChanged(DeltaProcessingState.java:477)
	at org.eclipse.core.internal.events.NotificationManager$1.run(NotificationManager.java:305)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.NotificationManager.notify(NotificationManager.java:295)
	at org.eclipse.core.internal.events.NotificationManager.broadcastChanges(NotificationManager.java:158)
	at org.eclipse.core.internal.resources.Workspace.broadcastPostChange(Workspace.java:380)
	at org.eclipse.core.internal.resources.Workspace.endOperation(Workspace.java:1502)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:169)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:244)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 09:25:06.593
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 09:29:11.173
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 09:30:04.427
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.util.concurrent.CompletableFuture.timedGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 09:44:42.836
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 09:47:13.216
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 11:30:19.335
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 13:27:22.928
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-04 18:13:54.123
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 18:22:19.841
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.YQgltwPq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 18:22:19.847
!MESSAGE unsubscribing from classpath changes: sts4.classpath.YQgltwPq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 18:22:19.854
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 18:22:19.861
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.YQgltwPq => OK

!ENTRY org.eclipse.ui 2 2 2020-11-04 18:22:20.582
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-04 19:32:19.026 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-04 19:32:48.858
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-04 19:32:48.858
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-04 19:32:52.166
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-04 19:32:52.166
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20a46227,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@669469c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:01.765
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:01.771
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@283eb984[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:01.784
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:02.018
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:04.510
!MESSAGE Boot LS startup time from start to initialized: 2674ms

!ENTRY org.eclipse.egit.ui 2 0 2020-11-04 19:33:04.617
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:04.933
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.AeLjvoesisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:04.952
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:04.976
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:05.019
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:05.073
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:05.086
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:05.103
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:05.111
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.AeLjvoes => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:05.991
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:06.010
!MESSAGE buffering callback sts4.classpath.AeLjvoes ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:06.017
!MESSAGE executing callback sts4.classpath.AeLjvoes 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 19:33:06.058
!MESSAGE executing callback sts4.classpath.AeLjvoes SUCCESS [done]

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-04 20:00:12.310
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jface 2 0 2020-11-04 20:04:59.136
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-04 20:04:59.136
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2e358c0d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@a79f15d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-04 20:13:47.745
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-04 20:27:11.426
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 22:19:47.719
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.AeLjvoes

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 22:19:47.726
!MESSAGE unsubscribing from classpath changes: sts4.classpath.AeLjvoes

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 22:19:47.732
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-04 22:19:47.738
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.AeLjvoes => OK

!ENTRY org.eclipse.ui 2 2 2020-11-04 22:19:48.376
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-05 08:58:55.589 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-05 08:59:12.860
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-05 08:59:12.860
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-05 08:59:17.130
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-05 08:59:17.130
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@357e7113,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8d23cd8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:30.033
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:30.033
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7008055[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:30.049
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:30.221
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-05 08:59:32.799
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.096
!MESSAGE Boot LS startup time from start to initialized: 3031ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.706
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.UocfDaBhisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.706
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.721
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.721
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.737
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.752
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.768
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.784
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.UocfDaBh => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.799
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.815
!MESSAGE buffering callback sts4.classpath.UocfDaBh ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.862
!MESSAGE executing callback sts4.classpath.UocfDaBh 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 08:59:33.893
!MESSAGE executing callback sts4.classpath.UocfDaBh SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 09:06:21.341
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 10:29:11.760
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 10:40:25.394
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:52:59.147
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = 
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-05 10:52:59.155
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-05 10:52:59.160
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:52:59.195
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = 
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:52:59.202
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:52:59.208
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:01.494
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = 
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:01.500
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:01.505
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:19.427
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = 
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:19.433
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:19.438
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:22.309
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = 
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:22.314
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:22.322
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:23.165
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = 
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:23.170
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:23.175
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:24.674
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = 
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:24.679
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:24.684
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:31.729
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] =
					
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-05 10:53:31.734
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-05 10:53:31.738
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:31.765
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] =
					
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:31.770
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:31.775
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:33.767
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] =
					
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-05 10:53:33.772
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-05 10:53:33.778
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:33.876
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] =
					
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:33.882
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:33.887
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:36.090
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] =
					
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor75.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:53:36.097
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor75.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:53:36.103
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:446)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:373)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:333)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction$1.run(ClipboardOperationAction.java:281)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:278)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor75.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:53:37.308
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true , false 
	//public static boolean gSoonFlag;//   
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true , false 
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	//   
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create   - 
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize     
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println(" input : "+ input);
	    //  
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println(" "+reserveInput);
	    
	    //  
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //    
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"  : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("    "+rsrvYetList);
	    return rsrvYetList;
	}
	
	//     - 
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("!!!!!!!!!!!");
		
//		System.out.println("  "+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println(""+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("  :"+temp);
//		System.out.println("  :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	//     - 
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	//    
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	//  
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	//  
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	//  
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	//  
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	//  
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	//  
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	//  - 
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("  :"+selectReservedScenarioList());
		System.out.println(" : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//    - 
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//    -
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	//  -   
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //   ()
		Map<String, Object> tempInput = new HashMap<String, Object>();//    
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//  
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			//    
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println(" "+loopCount);//   
				System.out.println(" "+actionCount);
				System.out.println(" "+wholeTime);
	
			}
			System.out.println("  ! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			//    
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("  ! "+wholeTime);
		}
		
		//wholeTime*1000 =  
		
		//    ,  +  
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("  + str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);// + 
		System.out.println("  + int) >>> "+iCurrentTime);
		
		
		System.out.println(" "+rsrvTimeArr);
		//  
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			// <= +    
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				// true  false ?
				System.out.println(" : "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ",   : "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("?: "+gExecuteFlag);

				return tempInput;// ??  
			}
		}
		
		//  
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//  
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//  (1 ) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//  (1 )
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//   
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 
			lScenarioList.add(rsrvYetList.get(index));//  1  
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update scenario(map), execute scenarioList(map<arraylist>) 
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...}  
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); // 
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//  
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//     
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));// db   
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: , 1: , 2: 
			//service.updateReserveScenario(scenario,""); //  
			
			// String  split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3
			String reserveHM[] = reserve[1].split(":");//2
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
			/**************************************************************************/
			//   
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("    .");
			}else {
				rsrvList.add(rsrvIndicator); //  
			}
			
			//timer 
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//    [{},{},{},{}]     >> run()   reserveId  List reserveId    
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//      
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					// id  [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//    
					//
					gExecuteFlag=true;//    on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
					
					//   
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);// ()
								
						
						//[rsrvId -- rsrvTime]
						//       rsrvId   Map  -     db     
						if(myTime.equals(timerTime)) {
							//id   ->    (temp[0])  , , 
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//    
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("  . "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								// if(myTime.equals())  
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
								//srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
								
								//    [{},{},{},{}]     >> run()   reserveId  List reserveId     >>   execute   !
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId   List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();// 1   List
								
								//={=[{},{},{},{}], sessionId=""}
								//      1  ??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//             . [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("  ");//mScenarioList      . >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db  
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status  ********************************/
								System.out.println("  "+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status  ********************************/
								
								System.out.println(" ? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"");//        ?
								System.out.println("  ");
								service.executeScenario(tempScenarioList);// ->   true
								service.updateReserveScenario(scenario, "");// 
								//////////
								lScenarioList.remove(lIndex);
							}
							//   
							rsrvList.remove(i);
						}
					}
					//    false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	//   - 
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//  
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		//    
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println(" "+loopCount);//   
			System.out.println(" "+actionCount);
			System.out.println(" "+wholeTime);

		}
		System.out.println("  ! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println(" input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//        >> reserve Table 
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);// RSRV_ID 
		
		//KEY 
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key Value 
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//    
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//  
		System.out.println("    "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("  >>>>>>>>>>>>>"+scenarioList);
		
		//  
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("      . >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/*********************************** overlapFlag   *********************************************/
		String reserveId = mapper.selectLastReserveId(input);//   
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//     
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);// db   
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/*********************************** overlapFlag   *********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);// input{scenario={rsrvId='1'}} 
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************  **********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//  id, time 
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("  "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		// 
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println(""+sTemp);
		
		System.out.println("   : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//  ,  
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] =
					rStartEndArr[i]
		}
		//   
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();// 
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();// 
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: , 1: , 2: 
		//service.updateReserveScenario(input,0,srTemp); //  
		service.updateReserveScenario(input,""); //  
		/**************************************************************************/
		//   
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("   "+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("   "+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("    .");
		}else {
			rsrvList.add(rsrvIndicator); //  
		}
		
		//System.out.println("!!! "+rsrvIndicator);
		//System.out.println("   "+date.getTimeInMillis());
		//db  
		
		

		
		//timer 
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//      
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				// id  [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//    
				//
				gExecuteFlag=true;//    on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer()
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer ()
				
				//   
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);// ()
							
					
					//[rsrvId -- rsrvTime]
					//       rsrvId   Map  -     db     
					if(myTime.equals(timerTime)) {
						//id   ->    (temp[0])  , , 
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0] : "+temp[0].getClass()+", listTemp.get(j) : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//    
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("  . "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							// if(myTime.equals())  
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update Map rsrvId 
							srTemp.put("reserveId", temp[0]);// Map srTemp rsrvId 
							
							//service.updateReserveScenario(input, 1, srTemp);// 
							service.updateReserveScenario(input,"");// test
							System.out.println("  ");
							
							service.executeScenario(scenarioList);// ->   true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);// 
							service.updateReserveScenario(input,"");// test
						}
						
						//   
						rsrvList.remove(i);

					}

				}
				//    false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		// String  split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3
		String reserveHM[] = reserve[1].split(":");//2
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!SESSION 2020-11-05 08:58:55.589 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file D:\SmartMobility\workspace\.metadata\.bak_2.log
Created Time: 2020-11-05 10:54:30.384

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:30.388
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:30.393
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:31.392
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-05 10:54:31.398
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-05 10:54:31.402
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:31.463
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:31.468
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:31.472
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:34.868
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:34.874
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:34.879
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:34.982
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:34.988
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:34.993
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:35.015
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:35.021
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:35.025
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:35.466
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:35.471
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:35.475
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:36.961
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:36.967
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:36.971
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:39.352
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:39.362
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:39.368
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:42.086
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:42.092
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:42.095
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:43.291
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:43.297
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:43.302
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:45.400
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:45.405
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:45.409
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:45.429
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:45.434
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:45.438
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:45.461
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:45.468
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:45.471
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:45.590
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:45.595
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:45.600
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:47.900
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:47.905
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:47.909
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:49.328
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:49.334
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:49.338
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:52.022
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:52.028
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:52.032
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:52.057
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:52.066
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:52.070
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:52.096
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:52.103
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:52.109
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:52.179
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:52.186
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:52.189
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:54.949
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:54.954
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:54.958
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:56.305
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:54:56.309
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:54:56.313
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:54:56.846
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[]
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!SESSION 2020-11-05 08:58:55.589 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file D:\SmartMobility\workspace\.metadata\.bak_4.log
Created Time: 2020-11-05 10:55:28.504

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:28.508
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:28.512
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:30.383
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve;
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:30.388
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:30.393
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:31.280
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2020-11-05 10:55:31.285
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2020-11-05 10:55:31.290
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:450)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:31.384
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:31.389
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:31.393
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:32.774
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:32.780
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:32.784
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:32.811
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:32.817
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:32.821
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:32.843
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:32.851
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:32.856
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:32.878
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:32.883
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:32.888
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:40.917
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:40.924
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:40.929
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:41.293
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:41.298
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:41.303
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:41.320
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:41.326
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:41.330
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:41.352
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:41.360
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:41.364
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:42.900
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:42.906
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:42.910
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:43.557
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:43.562
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:43.567
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.lambda$0(LSJavaHoverProvider.java:68)
	at java.util.concurrent.CompletableFuture$AsyncRun.run(Unknown Source)
	at java.util.concurrent.CompletableFuture$AsyncRun.exec(Unknown Source)
	at java.util.concurrent.ForkJoinTask.doExec(Unknown Source)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source)
	at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)
	at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:43.589
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:43.594
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:43.598
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:43.629
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:43.634
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:43.638
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1015)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:811)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2020-11-05 10:55:43.665
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package kr.tracom.smps.scenario.controller;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.Statement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Timer;
import java.util.TimerTask;

import javax.servlet.http.HttpServletRequest;
import javax.validation.constraints.Null;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

import kr.tracom.smps.handler.DataHandler;
import kr.tracom.smps.handler.ExecuteHandler;
import kr.tracom.smps.scenario.mapper.ScenarioMapper;
import kr.tracom.smps.scenario.service.ScenarioService;

@RestController
@RequestMapping("/api/v1")
public class ScenarioController {

	//park

	public static LinkedHashMap srTemp;
	public static ArrayList<String> rsrvList = new ArrayList<String>();
	public static boolean gExecuteFlag;//true면 실행, false면 미실행
	//public static boolean gSoonFlag;//곧 예약 시작한다는 플래그
	public static ArrayList<Long> rsrvTimeArr = new ArrayList<>(); 
	//public static boolean overlapFlag;//true면 미실행, false면 실행
	int index;
	
	@Autowired
	private ScenarioMapper mapper;
	//
	
	@Autowired
	private ScenarioService service; 
	
	// 시나리오 리스트 조회
	@GetMapping("/scenario")
	public Map<String, Object> selectScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		
		return service.selectScenarioList(input);
	}
	
	// create 쿼리 실행 - 박대원
	@PostMapping("/scenario/query")
	public void createQuery() {
		Connection con = null;
		Statement stmt=null;
		ResultSet rs = null;
		
		String dbFileUrl = "jdbc:sqlite:smartmobility.db";
		
		try {
			Class.forName("org.sqlite.JDBC");
			con=DriverManager.getConnection(dbFileUrl);
			System.out.println("SQLite DB connected");
			
			stmt = con.createStatement();
			rs = stmt.executeQuery("CREATE TABLE \"SMPS_COMM_RSRV\" (\r\n" + 
					"	\"RSRV_ID\"	INTEGER NOT NULL,\r\n" + 
					"	\"SNR_ID\"	TEXT,\r\n" + 
					"	\"SNR_NAME\"	TEXT,\r\n" + 
					"	\"RSRV_TIME\"	TEXT,\r\n" + 
					"	\"STATUS\"	TEXT,\r\n" + 
					"	\"CAN_YN\"	TEXT DEFAULT 'N',\r\n" + 
					"	\"SESSION_ID\"	TEXT,\r\n" + 
					"	PRIMARY KEY(\"RSRV_ID\" AUTOINCREMENT)\r\n" + 
					");");
			
		}catch(Exception e) {
			System.out.println(e);
		}
	}
	

	//Initialize할 때 예약 목록 있는지 확인
	@EventListener(ApplicationReadyEvent.class)
	public ArrayList<Map<String, Object>> reserveScanAfterStartup() {
		
		
		
	    System.out.println("hello world, I have just started up");
	    //System.out.println("받아온 input : "+ input);
	    //예약 리스트 받아오기
	    Map<String, Object> reserveInput = new HashMap<String, Object>();
	    reserveInput = service.selectReservedScenarioList(reserveInput);
	    
	    //System.out.println("request "+request);
	    //System.out.println("예약리스트 "+reserveInput);
	    
	    //예약 객체별로 확인
	    ArrayList<Map<String,Object>> rsrvList = new ArrayList<>();
	    ArrayList<Map<String,Object>> rsrvYetList = new ArrayList<>();
	    rsrvList = (ArrayList<Map<String, Object>>) reserveInput.get("reserveList");
	    
	    //대기중인 예약이 있다면 모두 가져옴
	    for(int i=0; i<rsrvList.size(); i++) {
	    	//System.out.println((i+1)+"번 예약 : "+rsrvList.get(i));
	    	if(rsrvList.get(i).get("status").equals("대기중")) {
	    		rsrvYetList.add(rsrvList.get(i));
	    	}
	    }
	    reserveScenario(rsrvYetList);
	    
	    //System.out.println("아직 실행 안된 예약들 "+rsrvYetList);
	    return rsrvYetList;
	}
	
	// 예약 시나리오 리스트 조회 - 박대원
	@GetMapping("/scenario/reserve")
	public Map<String, Object> selectReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		//System.out.println("예약조회!!!!!!!!!!!");
		
//		System.out.println("키 값 확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList"));
//		System.out.println("타입확인"+selectDeletedReservedScenarioList().get("deletedReservedScenarioList").getClass());
//		ArrayList<Map<String,Object>> temp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
//		System.out.println("임시저장값 확인 :"+temp);
//		System.out.println("임시저장값 크기확인 :"+temp.size());
//		System.out.println(temp.get(0));
		return service.selectReservedScenarioList(input);
	}
	
	// 삭제된 동작 시나리오 조회 - 박대원
	@GetMapping("/scenario/reserve/deleted")
	public Map<String, Object> selectDeletedReservedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedReservedScenarioList(input);
	}	
	
	// 삭제된 동작 시나리오 조회
	@GetMapping("/scenario/deleted")
	public Map<String, Object> selectDeletedScenarioList() {
		Map<String, Object> input = new HashMap<String, Object>();
		return service.selectDeletedScenarioList(input);
	}
	
	// 시나리오 삽입
	@PostMapping("/scenario")
	public boolean insertScenario(@RequestBody Map<String, Object> input) {
		return service.insertScenario(input);
	}
	
	// 시나리오 수정
	@PutMapping("/scenario")
	public boolean updateScenario(@RequestBody Map<String, Object> input) {
		return service.updateScenario(input);
	}
	
	// 시나리오 삭제
	@DeleteMapping("/scenario")
	public boolean deleteScenario(@RequestBody Map<String, Object> input) {
		return service.deleteScenario(input);
	}
	
	// 시나리오 복원
	@PostMapping("/scenario/recovery")
	public boolean recoveryScenario(@RequestBody Map<String, Object> input) {
		return service.recoveryScenario(input);
	}
	

	
	// 시나리오 실행
	@PostMapping("/scenario/execute")
	public void executeScenario(@RequestBody Map<String, Object> input, HttpServletRequest request) {
		if (input.containsKey("scenarioList") == true) {
			System.out.println("aaaaaaaaaaaa");
		}
		input.put("sessionId", request.getSession().getId());
		service.executeScenario(input);
		System.out.println("Scenario List : "+input.get("scenarioList"));
	}
	
	// 시나리오 중지
	@PostMapping("/scenario/pause")
	public void pauseScenario(HttpServletRequest request) {
		DataHandler handler = ExecuteHandler.sessionHandlerMap.get(request.getSession().getId());
		handler.setFlag(true);
		handler.processInsert();
	}
	
	
	// 예약취소 - 박대원
	@DeleteMapping("/scenario/reserve")
	public boolean cancelReserve(@RequestBody Map<String, Object> input) {		
		System.out.println("조회한 목록 :"+selectReservedScenarioList());
		System.out.println("삭제조회목록 : "+selectDeletedReservedScenarioList());
		return service.deleteReserve(input);
	}
	
//	//예약 시나리오 실행 유무 - 박대원
//	@GetMapping("/scenario/reserve/exflag")
//	public Map<String, Object> executeFlag(boolean eF) {
//		//int i = eF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("executeFlag", eF);
//		return input;
//	}
//	//예약 시간 중복 유무 -박대원
//	@GetMapping("/scenario/reserve/olflag")
//	public Map<String, Object> overlapFlag(boolean oF) {
//		//int i = oF ? 1 : 0;
//		Map<String, Object> input = new HashMap<String, Object>();
//		input.put("overlapFlag", oF);
//		return input;
//	}
	
	
	// 박대원 - 시나리오 실행 확인
	@PostMapping("/scenario/checkScenario")
	public Map<String, Object> checkScenario(@RequestBody Map<String, Object> input) {
		int wholeTime = 0; //현재 시간에서 더해질 시간(초단위)
		Map<String, Object> tempInput = new HashMap<String, Object>();//클라이언트에 플래그 값들 보낼 맵
//		if(gExecuteFlag==false) {
//			
//			return tempInput;
//		}
		//더해질 시간 구하기
		if (input.containsKey("scenarioList") == true) {
			List<Map<String, Object>> scenarioList = (List<Map<String, Object>>) input.get("scenarioList");
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			
			for(Map<String, Object> scenario : scenarioList) {
				int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
				int actTime=0;
				int actionCount = 0;
				List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
				
				for(Map<String, Object> action : actionList) {
					actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
					//
					System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
					System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
					System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
					actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				}
				totalCount += loopCount * actionCount;
				wholeTime += actTime;
				System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
				System.out.println("액션 "+actionCount);
				System.out.println("총시간 "+wholeTime);
	
			}
			System.out.println("시나리오 추가될 시간! "+wholeTime);
		}
		else if(input.containsKey("actionList") == true) {
			System.out.println("액션리스트!!!" +input.get("actionList"));
			List<Map<String, Object>> list = (List<Map<String, Object>>) input.get("actionList");
			
			// 총 삽입해야될 개수 계산
			int totalCount = 0;
			int actTime=0;
			for(Map<String, Object> action : list) {
				totalCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString());
				
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
				wholeTime += actTime;
			}
			
			System.out.println("액션 추가될 시간! "+wholeTime);
		}
		
		//wholeTime*1000 = 더해질 밀리초
		
		//현재 실제 시간 가져오기 , 현재시간 + 더해질 시간
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sCurrentTime = format1.format(System.currentTimeMillis()+(wholeTime*1000));
		System.out.println("현재 실행하려는 시간+실행시간 str) >>> "+sCurrentTime);
		int iCurrentTime = Integer.parseInt(sCurrentTime);//현재시간 + 수행시간
		System.out.println("현재 실행하려는 시간+실행시간 int) >>> "+iCurrentTime);
		
		
		System.out.println("야야투레 "+rsrvTimeArr);
		//예약시작시간들과 현재시간 비교하기
		for(int i=0; i<rsrvTimeArr.size(); i++) {
			//예약시작시간 <= 현재시작시간+총동작시간 이면 예약이 돌때 실행
			if(rsrvTimeArr.get(i) <= System.currentTimeMillis()+(wholeTime*1000)) {
				//이때 true로 바꿔줌 false로는 언제가?
				System.out.println("예상 종료시간: "+(System.currentTimeMillis()+((long)wholeTime*1000))+ ", 예약 시작 시간: "+rsrvTimeArr);
				
				tempInput = new HashMap<String, Object>();
				tempInput.put("executeFlag", true);
				
				//rsrvTimeArr.remove(i);
				System.out.println("실행중인가?: "+gExecuteFlag);

				return tempInput;//담아만 두기?? 한번에 보내나
			}
		}
		
		//예약 실행중이니 안됨
		if (gExecuteFlag == true) {
			tempInput = new HashMap<String, Object>();
			tempInput.put("executeFlag", true);
			
			return tempInput;
		}
		
		return tempInput;
	}
	
	
	/*************************************************************************************************************/
	public void reserveScenario(ArrayList<Map<String, Object>> rsrvYetList) {
		
		boolean isOverlapFlag = false;
		//srTemp = new LinkedHashMap();
		String reserveTime;
		String reserveId;
		//Map<String, Object> scenario = new HashMap<String,Object>();
		Map<String, Object> mScenarioList = new HashMap<String,Object>();//모든 미완료 예약정보
		List<Map<String, Object>> lScenarioList = new ArrayList<Map<String, Object>>(); 
		
		Map<String, Object> tempScenarioList = new HashMap<String,Object>();//실행시킬 미완료 예약정보(1개씩만 들어감) 
		//Map<String, Object> tempScenario = new HashMap<String,Object>();//상태변경시킬 미완료 예약정보(1개씩만 들어감)
		
		//rsrvYetList.get(0).put("loopCount", 1);
		//System.out.println(rsrvYetList);
		
		//미완료 예약들 한개씩 시작
		for(index=0; index<rsrvYetList.size(); index++) {
			
			rsrvYetList.get(index).put("loopCount", 1);
			
			//clear 해줘야함
			lScenarioList.add(rsrvYetList.get(index));//예약 객체 1개씩만 넣기 위해
			//System.out.println("zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz : "+lScenarioList);
			
			//update할때는 scenario(map)매개변수, execute할때는 scenarioList(map<arraylist>) 매개변수
			mScenarioList.put("scenarioList", lScenarioList);//scenarioList={...} 꼴로 변경
			mScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			tempScenarioList.put("scenarioList", lScenarioList);
			tempScenarioList.put("sessionId", rsrvYetList.get(index).get("sessionId"));
			
			//scenario.put("scenario", mScenarioList);
			//tempScenario.put("scenario", mScenarioList);
			//System.out.println("scenario확인!: "+scenario);
			
			
			reserveTime = (String) rsrvYetList.get(index).get("reserveTime"); //미완료 예약시간
			
			
//			ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
//			System.out.println("overlap check : "+overlapCheck);
//			for(int k=0; k<overlapCheck.size()-1;k++){
//				if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
//					System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
//					isOverlapFlag = true;
//				}
//			}
			
			reserveId =  String.valueOf(rsrvYetList.get(index).get("reserveId"));//미완료 예약 아이디
			ArrayList<Integer> reserveIds = new ArrayList<>();
			reserveIds.add(Integer.parseInt(reserveId));
			
			//예약클릭 시  중복이라면 여기서 종료
			if (isOverlapFlag == true) {
				Map<String, Object> tempInput = new HashMap<String, Object>();
				tempInput.put("overlaps", true);
				
				rsrvYetList.get(index).put("reserveIds", reserveIds);
				service.deleteReserve(rsrvYetList.get(index));//중복 db 삭제 되는지 확인
				System.out.println("reserve overlap!"+rsrvYetList.get(index));
				return;
			}
			
			//0: 대기중, 1: 실행중, 2: 실행완료
			//service.updateReserveScenario(scenario,"대기중"); // 대기중으로 설정
			
			//받은 String 년월일시분 split
			int ymd_hm[] = new int[5];
			
			String reserve[] = reserveTime.split("_");
			String reserveYMD[] = reserve[0].split("/");//3개
			String reserveHM[] = reserve[1].split(":");//2개
			
			
			ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
			ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
			ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
			
			ymd_hm[3] = Integer.parseInt(reserveHM[0]);
			ymd_hm[4] = Integer.parseInt(reserveHM[1]);
			
			
			Calendar date = Calendar.getInstance();
			date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
			//
			
			
			
			String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
			/**************************************************************************/
			//예약날짜들 전역 예약날짜배열에 삽입
			rsrvTimeArr.add(date.getTimeInMillis());
			/**************************************************************************/
			if(isOverlapFlag==true) {
				System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
			}else {
				rsrvList.add(rsrvIndicator); //예약 배열에 추가
			}
			
			//timer 작업
			Timer timer = new Timer();
			//TimerTask timerTask = new TimerTask()
			TimerTask timerTask = new TimerTask() {
				
				@Override
				public void run() {
					// TODO Auto-generated method stub
					
					//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자
					
					
					
					
//					System.out.println("1. rsrvList : "+rsrvList);
//					System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
//					System.out.println("current Time"+System.currentTimeMillis());
					
					//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
					for(int i=0; i<rsrvTimeArr.size();i++) {
						if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
							rsrvTimeArr.remove(i);
						}
					}
					
					//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
					ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
					//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
					//boolean executeFlag = true;
					boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
					//
					gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
					
				
					String myTime;
					String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
					String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
					
					//비교할 시간 문자열 설정
					for(int i=0; i<rsrvList.size();i++) {
						String temp[]=rsrvList.get(i).split(",");//id, time 분리
						System.out.println(temp[0]+" "+temp[1]);
						myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
								
						
						//[rsrvId -- rsrvTime]
						//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
						if(myTime.equals(timerTime)) {
							//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
							for(int j=0; j<listTemp.size(); j++) {		
								//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
								//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
								
								//삭제된 예약들이 실행되지 않도록 구분
								if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
									System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
									executeFlag = false;
								}
							}
							
							if(executeFlag) {
								//원래 if(myTime.equals())안에 있던 함수들
								//((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
								//srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
								
								//맨처음에 넘어온 모든 미완료 값[{},{},{},{}]에서 하나씩만 골라낼 수 있을까 >> run() 시작될 때의 reserveId 값과 List값의 reserveId를 비교하여 같은 것을 보내자 >> 골라낸 리스트만 execute에 추가해서 실행하면 된다!
								ArrayList<Map<String, Object>> tt = new ArrayList<Map<String, Object>>();//reserveId를 가져오기 위한 List
								tt = (ArrayList<Map<String, Object>>) mScenarioList.get("scenarioList");
								int lIndex = 0;
								ArrayList<Map<String, Object>> ttExecute = new ArrayList<Map<String, Object>>();//실행될 1가지 시나리오만 담는 List
								
								//시나리오={시나리오리스트=[{},{},{},{}], sessionId=""}
								//그러면 여기서 시나리오라는 맵을 생성해서 위에서 1개씩만 넣으면 그만??
								Map<String, Object> scenario = new HashMap<String,Object>();
								Map<String, Object> tempScenario = new HashMap<String,Object>();
								
								//모든 예약 시나리오 중 현재 시간에 맞는 시나리오리스트를 찾아 단 한개의 시나리오만 실행되도록 한다. [{},{},{}]
								for(int k=0; k<lScenarioList.size(); k++) {
									System.out.println("예약아이디....."+tt.get(k).get("reserveId")+" ,"+temp[0]);
									if(temp[0].equals(String.valueOf(tt.get(k).get("reserveId")))) {
										System.out.println("이럼 거의 끝");//mScenarioList는 미완료 목록 전체이기 때문에 바뀌면 안됨. >> ??
										ttExecute.add(tt.get(k));
										tempScenarioList.put("scenarioList", ttExecute);
										
										//db작업하기 위한 맵
										tempScenario.put("scenarioList", ttExecute);
										scenario.put("scenario", tempScenario);
										
										lIndex = k;
									}
								}
								/**************************status변경위해 여기 추가함********************************/
								System.out.println("시나리오에 들어갈 아이디"+tt.get(lIndex).get("reserveId"));
								((HashMap) scenario.get("scenario")).put("reserveId", tt.get(lIndex).get("reserveId"));
								/**************************status변경위해 여기 추가함********************************/
								
								System.out.println("뭐 어떤데? "+tempScenarioList);
								
								
								
								service.updateReserveScenario(scenario,"실행중");//상태갱신 이것도 모든 예약 리스트 다 들어가서 못읽는거 아닐까?
								System.out.println("예약 시나리오 시작");
								service.executeScenario(tempScenarioList);//실행 -> 실행 플래그 true
								service.updateReserveScenario(scenario, "실행완료");//상태갱신 
								//////////
								lScenarioList.remove(lIndex);
							}
							//실행완료 후 예약배열에서 삭제
							rsrvList.remove(i);
						}
					}
					//타이머 끝나면 실행 플래그 false
					gExecuteFlag=false;
				}
				//input.put("sessionId", request.getSession().getId());
			};
			//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
			timer.schedule(timerTask, new Date(date.getTimeInMillis()));
			
		}

	}
	/*************************************************************************************************************/
	
	
	
	
	
	
	
	
	
	

	// 시나리오 예약 - 박대원
	@PostMapping("/scenario/reserve")
	public Map<String, Object> reserveScenario(@RequestBody Map<String, Object> input,HttpServletRequest request) {
		//service.updateScenario(input);
		boolean isOverlapFlag = false;
		

		int wholeTime = 0;
		//더해질 시간 구하기
		
		Map<String, Object> sc = (Map<String, Object>) input.get("scenario");  
		List<Map<String, Object>> scList = (List<Map<String, Object>>) sc.get("scenarioList");
		// 총 삽입해야될 개수 계산
		int totalCount = 0;
		
		for(Map<String, Object> scenario : scList) {
			int loopCount = Integer.parseInt(scenario.get("loopCount").toString());
			int actTime=0;
			int actionCount = 0;
			List<Map<String, Object>> actionList = (List<Map<String,Object>>) scenario.get("actionList");
			
			for(Map<String, Object> action : actionList) {
				actionCount += Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("userCount").toString()); 
				//
				System.out.println("반복횟수..? "+Integer.parseInt(action.get("loopCount").toString()));
				System.out.println("기준시간..? "+ Integer.parseInt(action.get("timeSet").toString()));
				System.out.println("타임아웃..? "+ Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3)));
				actTime += (Integer.parseInt(action.get("loopCount").toString()) * Integer.parseInt(action.get("timeSet").toString())) + Integer.parseInt(action.get("timeout").toString().substring(0,action.get("timeout").toString().length()-3));
			}
			totalCount += loopCount * actionCount;
			wholeTime += actTime;
			System.out.println("루프 "+loopCount);// 시나리오 자체의 루프
			System.out.println("액션 "+actionCount);
			System.out.println("총시간 "+wholeTime);

		}
		System.out.println("시나리오 추가될 시간! "+wholeTime);
	
		
		
		
		
		
		
		
		
		System.out.println("초기 input :"+input);
//		System.out.println("request "+ request.getSession().getId());
//		Map<String, Object> temp = (Map<String, Object>) input.get("scenario");
//		temp.get("scenarioList");
		
		
		//최초 예약 시 세션 아이디 설정해서 맵에 넣어줌 >> reserve Table에도 저장해야함
		input.put("sessionId", request.getSession().getId());
		

		service.insertReserve(input);//여기서 RSRV_ID 생성됨
		
		//KEY 확인용
		Set set = input.keySet();
		Iterator iterator = set.iterator();
		
		while(iterator.hasNext()) {
			String key = (String)iterator.next();
			//System.out.println("input key : "+ key);
		}
		//Key의 Value 확인용
		//System.out.println(input.get("scenario"));
		//System.out.println(input.get("actionIds"));
		///////////////////////////////////////////////////////////////
		/**************************************************************/
		//받아온 예약 내용 저장 
		srTemp = new LinkedHashMap();
		String reserveTime;
		Map<String, Object> scenarioList = new HashMap<String,Object>();
		
		srTemp = (LinkedHashMap) input.get("scenario");
		reserveTime = (String) srTemp.get("reserveTime");
		
		//시나리오리스트 형태 테스트
		System.out.println("시나리오 리스트 어떻게 생김 "+ srTemp.get("scenarioList"));
		
		scenarioList.put("scenarioList", srTemp.get("scenarioList"));
		scenarioList.put("sessionId", request.getSession().getId());
		/**************************************************************/
		//System.out.println("확인좀 해보자 >>>>>>>>>>>>>"+scenarioList);
		
		//예약시간 중복 확인
		ArrayList<Map<String,Object>> overlapCheck = (ArrayList<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		for(int k=0; k<overlapCheck.size()-1;k++){
			if(reserveTime.equals(overlapCheck.get(k).get("reserveTime"))){
				//System.out.println("지금 예약한 시간에 이미 다른 예약이 있습니다. >> " +overlapCheck.get(k).get("reserveId")+" "+overlapCheck.get(k).get("reserveTime"));
				isOverlapFlag = true;
			}
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		String reserveId = mapper.selectLastReserveId(input);//맨 마지막 예약 아이디
		ArrayList<Integer> reserveIds = new ArrayList<>();
		reserveIds.add(Integer.parseInt(reserveId));
		
		//예약클릭 시  중복이라면 여기서 종료
		if (isOverlapFlag == true) {
			Map<String, Object> tempInput = new HashMap<String, Object>();
			tempInput.put("overlaps", true);
			
			input.put("reserveIds", reserveIds);
			service.deleteReserve(input);//중복 db 삭제 되는지 확인
			System.out.println("reserve overlap!"+input);
			return tempInput;
		}
		/***********************************여기에서 overlapFlag 전송할 수 있도록*********************************************/
		
		
		((Map<String, Object>)input.get("scenario")).put("reserveId", reserveId);//이제 input{scenario={rsrvId='1'}} 추가됨
		
		Calendar date = Calendar.getInstance();
		date = timeSplit(reserveTime);
		
		/************************************예약겹치는 함수 생성중**********************************************/
		String rsrvIndicator = reserveId+","+date.getTimeInMillis();//현재 예약 id, time 기억
		
		long reserveEnd = date.getTimeInMillis()+(long)wholeTime*1000;
		System.out.println("예상 추가시간 "+ (long)wholeTime*1000);
		((HashMap) input.get("scenario")).put("reserveEnd", reserveEnd);
		//종료시간맞는지 테스트
		SimpleDateFormat fm1 = new SimpleDateFormat ("yy/MM/dd_HH:mm:ss");
		String sTemp = fm1.format(reserveEnd);
		System.out.println("예상종료시간"+sTemp);
		
		System.out.println("저장된 모든 내용 : "+selectReservedScenarioList().get("reserveList"));
		List<Map<String, Object>> reserveOverlap = (List<Map<String, Object>>) selectReservedScenarioList().get("reserveList");
		//모든 예약 시작,종료 시간들을 담자
		long rStartEndArr[] = new long[reserveOverlap.size()];
		long iStartReserve;
		long iEndReserve;
		for(int i=0; i<reserveOverlap.size(); (i+2)) {
			iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
			iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
			
			rStartEndArr[i] = iStartReserve
			
		}
		//모든 예약 객체를 스캔
		for(int i=0; i<reserveOverlap.size(); i++) {
			for(int j=0; j<reserveOverlap.size(); j++) {
				long iStartReserve = timeSplit((String) reserveOverlap.get(i).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long iEndReserve = (long) reserveOverlap.get(i).get("reserveEnd");
				
				long jStartReserve = timeSplit((String) reserveOverlap.get(j).get("reserveTime")).getTimeInMillis();//시작 밀리초
				long jEndReserve = (long) reserveOverlap.get(j).get("reserveEnd");
				
				if(iStartReserve<jEndReserve ) {
					
				}
			}
		}
		
		//0: 대기중, 1: 실행중, 2: 실행완료
		//service.updateReserveScenario(input,0,srTemp); // 대기중으로 설정
		service.updateReserveScenario(input,"대기중"); // 대기중으로 설정
		/**************************************************************************/
		//예약날짜들 전역 예약날짜배열에 삽입
		SimpleDateFormat format1 = new SimpleDateFormat ("yyMMddHHmm");
		String sdateTemp = format1.format(date.getTimeInMillis());
		//rsrvTimeArr = date.getTimeInMillis();/////////////////////////////
		//System.out.println("현재 시간 어떻게 들어오냐"+ sdateTemp);
		int idateTemp = Integer.parseInt(sdateTemp);
		//System.out.println("현재 시간 어떻게 들어오냐"+ idateTemp);
		//rsrvTimeArr.add(idateTemp);
		
		rsrvTimeArr.add(date.getTimeInMillis());
		/**************************************************************************/
		if(isOverlapFlag==true) {
			System.out.println("중복 예약이므로 예약목록에 담지 않겠습니다.");
		}else {
			rsrvList.add(rsrvIndicator); //예약 배열에 추가
		}
		
		//System.out.println("리스트!!! "+rsrvIndicator);
		//System.out.println("내가 설정한 시간 "+date.getTimeInMillis());
		//db 예약상태 업데이트
		
		

		
		//timer 작업
		Timer timer = new Timer();
		//TimerTask timerTask = new TimerTask()
		TimerTask timerTask = new TimerTask() {
			
			@Override
			public void run() {
				// TODO Auto-generated method stub
				
//				System.out.println("야호ㅗㅗㅗㅗ");
//				System.out.println(rsrvTimeArr);
//				
//				System.out.println("킥킥ㅗㅗㅗㅗ");
//				System.out.println(System.currentTimeMillis());
				
				System.out.println("1. rsrvList : "+rsrvList);
				System.out.println("2. rsrvTimeArr : "+rsrvTimeArr);
				System.out.println("current Time"+System.currentTimeMillis());
				
				//예약시간과 실행시간이 같으면 실행완료예약이니 예약 배열에서 삭제
				for(int i=0; i<rsrvTimeArr.size();i++) {
					if(rsrvTimeArr.get(i)-100 < System.currentTimeMillis() && rsrvTimeArr.get(i)+100 > System.currentTimeMillis()) {
						rsrvTimeArr.remove(i);
					}
				}
				
				//삭제된 예약id와 예약시간 [{id,time}, {id,time}, {id,time}]
				ArrayList<Map<String,Object>> listTemp = (ArrayList<Map<String, Object>>) selectDeletedReservedScenarioList().get("deletedReservedScenarioList");
				//System.out.println("삭제조회목록222 : "+selectDeletedReservedScenarioList());
				//boolean executeFlag = true;
				boolean executeFlag = true;//중복시 하나만 실행하기 위한 플래그
				//
				gExecuteFlag=true;//예약 실행될 때 예약실행플래그 on
				
			
				String myTime;
				String timerTemp = String.valueOf(System.currentTimeMillis());//timer시간(밀리초포함)
				String timerTime = timerTemp.substring(0, timerTemp.length()-3);//timer시간 (밀리초제거)
				
				//비교할 시간 문자열 설정
				for(int i=0; i<rsrvList.size();i++) {
					String temp[]=rsrvList.get(i).split(",");//id, time 분리
					System.out.println(temp[0]+" "+temp[1]);
					myTime = temp[1].substring(0, temp[1].length()-3);//내 시간(밀리초제거)
							
					
					//[rsrvId -- rsrvTime]
					//내가 설정한 시간과 타이머의 시간이 같으면 내 rsrvId를 가져온 후 Map에 추가 - 이 작업을 하지 않으면 db의 마지막 행의 상태만 바뀌게 됨
					if(myTime.equals(timerTime)) {
						//id 값 가져왔음 -> 예약 실행되는 현재 인덱스(temp[0]) 파악함 , 검사로직, 추가됨
						for(int j=0; j<listTemp.size(); j++) {		
							//System.out.println("temp[0]형식 : "+temp[0].getClass()+", listTemp.get(j)형식 : "+listTemp.get(j).get("reserveId").getClass());
							//System.out.println("t/f판단"+temp[0].equals(listTemp.get(j).get("reserveId"))+",temp[0] : "+temp[0]+", listTemp.get(j): "+listTemp.get(j).get("reserveId"));
							
							//삭제된 예약들이 실행되지 않도록 구분
							if(temp[0].equals(String.valueOf(listTemp.get(j).get("reserveId")))) {
								System.out.println("삭제된 예약과 중복됩니다. "+listTemp.get(j).get("reserveId"));
								executeFlag = false;
							}
						}
						
						if(executeFlag) {
							//원래 if(myTime.equals())안에 있던 함수들
							((Map<String, Object>)input.get("scenario")).put("reserveId", temp[0]);//update할 Map에 rsrvId 갱신
							srTemp.put("reserveId", temp[0]);//복사할 Map인 srTemp에도 rsrvId 갱신
							
							//service.updateReserveScenario(input, 1, srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행중");//상태갱신 test
							System.out.println("예약 시나리오 시작");
							
							service.executeScenario(scenarioList);//실행 -> 실행 플래그 true
							//service.updateReserveScenario(input, 2, ScenarioController.srTemp);//상태갱신 
							service.updateReserveScenario(input,"실행완료");//상태갱신 test
						}
						
						//실행완료 후 예약배열에서 삭제
						rsrvList.remove(i);

					}

				}
				//타이머 끝나면 실행 플래그 false
				gExecuteFlag=false;
			}
			//input.put("sessionId", request.getSession().getId());
		};

		//timer.schedule(timerTask, new Date(date.getTimeInMillis()), 24*60*60*1000);
		timer.schedule(timerTask, new Date(date.getTimeInMillis()));
		
		
		return input;
	}
	
	
	public Calendar timeSplit(String reserveTime) {
		//받은 String 년월일시분 split
		int ymd_hm[] = new int[5];
		
		String reserve[] = reserveTime.split("_");
		String reserveYMD[] = reserve[0].split("/");//3개
		String reserveHM[] = reserve[1].split(":");//2개
		
		
		ymd_hm[0] = Integer.parseInt(reserveYMD[0]);
		ymd_hm[1] = Integer.parseInt(reserveYMD[1]);
		ymd_hm[2] = Integer.parseInt(reserveYMD[2]);
		
		ymd_hm[3] = Integer.parseInt(reserveHM[0]);
		ymd_hm[4] = Integer.parseInt(reserveHM[1]);
		
		
		Calendar date = Calendar.getInstance();
		date.set(ymd_hm[0],ymd_hm[1]-1,ymd_hm[2],ymd_hm[3],ymd_hm[4],0);
		
		return date;
	}
	
	
}



----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2020-11-05 10:55:43.673
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2020-11-05 10:55:43.680
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1276)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2020)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3750)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3602)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2190)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3302)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1231)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:820)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:271)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:263)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:196)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:186)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:175)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$3.run(SelectionListenerWithASTManager.java:160)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 10:57:07.736
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 10:57:28.161
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 11:11:14.590
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 11:25:44.151
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 12:03:24.796
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.UocfDaBh

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 12:03:24.802
!MESSAGE unsubscribing from classpath changes: sts4.classpath.UocfDaBh

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 12:03:24.808
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 12:03:24.814
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.UocfDaBh => OK

!ENTRY org.eclipse.ui 2 2 2020-11-05 12:03:25.365
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-05 13:11:57.648 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-05 13:12:09.731
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-05 13:12:09.731
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-05 13:12:14.012
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-05 13:12:14.012
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@322f84fd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@113cc14d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:28.386
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:28.391
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1053b20d[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:28.408
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:28.617
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-05 13:12:31.052
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:32.664
!MESSAGE Boot LS startup time from start to initialized: 4220ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.092
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.BHYXaFVqisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.107
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.114
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.127
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.140
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.148
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.161
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.184
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.BHYXaFVq => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.221
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.236
!MESSAGE buffering callback sts4.classpath.BHYXaFVq ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.243
!MESSAGE executing callback sts4.classpath.BHYXaFVq 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 13:12:33.279
!MESSAGE executing callback sts4.classpath.BHYXaFVq SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 14:08:17.405
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 16:05:58.239
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 17:48:09.116
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 17:51:27.098
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-05 17:56:15.598
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 18:31:20.917
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.BHYXaFVq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 18:31:20.924
!MESSAGE unsubscribing from classpath changes: sts4.classpath.BHYXaFVq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 18:31:20.928
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-05 18:31:20.934
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.BHYXaFVq => OK

!ENTRY org.eclipse.ui 2 2 2020-11-05 18:31:21.463
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-06 08:58:34.989 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-06 08:58:43.898
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-06 08:58:43.898
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-06 08:58:48.259
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-06 08:58:48.259
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@669469c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f39ad3f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:01.687
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:01.693
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@b303504[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:01.716
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:01.909
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-06 08:59:04.120
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:05.884
!MESSAGE Boot LS startup time from start to initialized: 4148ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.235
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.fXerLlaWisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.244
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.252
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.262
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.271
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.278
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.287
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.296
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.fXerLlaW => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.336
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.362
!MESSAGE buffering callback sts4.classpath.fXerLlaW ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.369
!MESSAGE executing callback sts4.classpath.fXerLlaW 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 08:59:06.407
!MESSAGE executing callback sts4.classpath.fXerLlaW SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-06 09:03:14.755
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 18:24:56.723
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.fXerLlaW

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 18:24:56.728
!MESSAGE unsubscribing from classpath changes: sts4.classpath.fXerLlaW

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 18:24:56.734
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-06 18:24:56.739
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.fXerLlaW => OK

!ENTRY org.eclipse.ui 2 2 2020-11-06 18:24:57.363
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-08 18:36:33.170 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-08 18:36:40.615
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-08 18:36:40.615
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-08 18:36:45.060
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-08 18:36:45.060
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@357e7113,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8d23cd8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:00.457
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:00.464
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@38905461[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:00.478
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:00.670
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.156
!MESSAGE Boot LS startup time from start to initialized: 3644ms

!ENTRY org.eclipse.egit.ui 2 0 2020-11-08 18:37:04.345
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.590
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.eLJtGqWHisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.598
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.605
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.613
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.622
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.629
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.635
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.641
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.eLJtGqWH => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.661
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.676
!MESSAGE buffering callback sts4.classpath.eLJtGqWH ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.683
!MESSAGE executing callback sts4.classpath.eLJtGqWH 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-08 18:37:04.760
!MESSAGE executing callback sts4.classpath.eLJtGqWH SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-08 20:43:35.567
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2020-11-09 16:47:09.295
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:07.769
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.eLJtGqWH

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:07.791
!MESSAGE unsubscribing from classpath changes: sts4.classpath.eLJtGqWH

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:07.796
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:07.801
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.eLJtGqWH => OK
!SESSION 2020-11-09 17:17:18.891 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-09 17:17:25.461
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-09 17:17:25.461
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-09 17:17:28.685
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-09 17:17:28.685
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@669469c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f39ad3f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:39.881
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:39.887
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@10cd5b30[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:39.900
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:40.067
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-09 17:17:42.089
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.370
!MESSAGE Boot LS startup time from start to initialized: 3441ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.602
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ShbYimQhisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.610
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.615
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.622
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.629
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.633
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.638
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.643
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ShbYimQh => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.659
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.671
!MESSAGE buffering callback sts4.classpath.ShbYimQh ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.676
!MESSAGE executing callback sts4.classpath.ShbYimQh 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 17:17:43.710
!MESSAGE executing callback sts4.classpath.ShbYimQh SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-09 17:20:00.996
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-09 17:50:46.468
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-09 18:02:31.999
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 18:04:49.498
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ShbYimQh

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 18:04:49.498
!MESSAGE unsubscribing from classpath changes: sts4.classpath.ShbYimQh

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 18:04:49.514
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 18:04:49.514
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ShbYimQh => OK
!SESSION 2020-11-09 19:42:23.692 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-09 19:42:31.736
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-09 19:42:31.736
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-09 19:42:35.453
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-09 19:42:35.453
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@548c5127,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35630ee8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:50.227
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:50.235
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1c028ae2[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:50.256
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:50.439
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-09 19:42:53.575
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:54.937
!MESSAGE Boot LS startup time from start to initialized: 4660ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.420
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.xslqLPttisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.428
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.436
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.444
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.453
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.461
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.468
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.473
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.xslqLPtt => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.529
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.553
!MESSAGE buffering callback sts4.classpath.xslqLPtt ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.560
!MESSAGE executing callback sts4.classpath.xslqLPtt 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-09 19:42:55.607
!MESSAGE executing callback sts4.classpath.xslqLPtt SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 18:08:58.725
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.xslqLPtt

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 18:08:58.758
!MESSAGE unsubscribing from classpath changes: sts4.classpath.xslqLPtt

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 18:08:58.763
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 18:08:58.768
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.xslqLPtt => OK

!ENTRY org.eclipse.ui 2 2 2020-11-10 18:08:59.347
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-10 20:06:31.177 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-10 20:06:38.507
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-10 20:06:38.507
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-10 20:06:42.949
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-10 20:06:42.949
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@16f15a4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@548c5127,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:06:57.156
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:06:57.161
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@473c1e53[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:06:57.175
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:06:57.326
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-10 20:07:00.943
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:01.573
!MESSAGE Boot LS startup time from start to initialized: 4379ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.023
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.HAeQtIhqisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.031
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.039
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.047
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.054
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.061
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.068
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.074
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.HAeQtIhq => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.110
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.122
!MESSAGE buffering callback sts4.classpath.HAeQtIhq ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.126
!MESSAGE executing callback sts4.classpath.HAeQtIhq 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-10 20:07:02.162
!MESSAGE executing callback sts4.classpath.HAeQtIhq SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 01:15:12.065
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.HAeQtIhq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 01:15:12.071
!MESSAGE unsubscribing from classpath changes: sts4.classpath.HAeQtIhq

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 01:15:12.077
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 01:15:12.083
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.HAeQtIhq => OK

!ENTRY org.eclipse.ui 2 2 2020-11-11 01:15:12.852
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-11 08:52:07.304 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-11 08:52:11.822
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-11 08:52:11.822
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-11 08:52:13.527
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-11 08:52:13.527
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f39ad3f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7524125c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:22.647
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:22.662
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@23f37949[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:22.662
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:22.725
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-11 08:52:24.650
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.009
!MESSAGE Boot LS startup time from start to initialized: 3315ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.290
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.jgILoHLJisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.290
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.306
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.306
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.306
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.322
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.322
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.322
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.jgILoHLJ => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.368
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.384
!MESSAGE buffering callback sts4.classpath.jgILoHLJ ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.384
!MESSAGE executing callback sts4.classpath.jgILoHLJ 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 08:52:26.415
!MESSAGE executing callback sts4.classpath.jgILoHLJ SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-11 13:53:50.894
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.ui 4 0 2020-11-11 13:54:09.698
!MESSAGE Cannot create or restore 'statistics.out.xml' because it already exists.
!STACK 0
org.eclipse.core.commands.ExecutionException: Cannot create or restore 'statistics.out.xml' because it already exists.
	at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.undo(UndoableOperation2ChangeAdapter.java:212)
	at org.eclipse.core.commands.operations.TriggeredOperations.undo(TriggeredOperations.java:214)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.doUndo(DefaultOperationHistory.java:407)
	at org.eclipse.core.commands.operations.DefaultOperationHistory.undo(DefaultOperationHistory.java:1149)
	at org.eclipse.ui.operations.UndoActionHandler.runCommand(UndoActionHandler.java:86)
	at org.eclipse.ui.operations.OperationHistoryActionHandler.lambda$0(OperationHistoryActionHandler.java:288)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.jface.dialogs.ProgressMonitorDialog.run(ProgressMonitorDialog.java:469)
	at org.eclipse.ui.internal.operations.TimeTriggeredProgressMonitorDialog.access$6(TimeTriggeredProgressMonitorDialog.java:1)
	at org.eclipse.ui.internal.operations.TimeTriggeredProgressMonitorDialog.lambda$0(TimeTriggeredProgressMonitorDialog.java:155)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.operations.TimeTriggeredProgressMonitorDialog.run(TimeTriggeredProgressMonitorDialog.java:167)
	at org.eclipse.ui.operations.OperationHistoryActionHandler.run(OperationHistoryActionHandler.java:301)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Tree.WM_CHAR(Tree.java:5940)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Tree.windowProc(Tree.java:5935)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)
Caused by: Java Model Exception: Core Exception [code 0] Cannot create or restore 'statistics.out.xml' because it already exists.
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:52)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5895)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:106)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.access$0(DynamicValidationStateChange.java:1)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.lambda$0(DynamicValidationStateChange.java:105)
	at org.eclipse.jdt.internal.core.BatchOperation.executeOperation(BatchOperation.java:41)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.jdt.core.JavaCore.run(JavaCore.java:5895)
	at org.eclipse.jdt.internal.corext.refactoring.changes.DynamicValidationStateChange.perform(DynamicValidationStateChange.java:106)
	at org.eclipse.ltk.core.refactoring.CompositeChange.perform(CompositeChange.java:281)
	at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.lambda$0(UndoableOperation2ChangeAdapter.java:329)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2312)
	at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.executeChange(UndoableOperation2ChangeAdapter.java:351)
	at org.eclipse.ltk.internal.core.refactoring.UndoableOperation2ChangeAdapter.undo(UndoableOperation2ChangeAdapter.java:196)
	... 70 more

!ENTRY org.eclipse.lsp4e 2 0 2020-11-11 14:05:18.217
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-11 14:16:49.466
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-11 14:24:43.227
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:29.194
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.jgILoHLJ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:29.213
!MESSAGE unsubscribing from classpath changes: sts4.classpath.jgILoHLJ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:29.217
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:29.223
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.jgILoHLJ => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:36.505
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:36.510
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@23f37949[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:36.515
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.017
!MESSAGE Boot LS startup time from start to initialized: 2494ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.065
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.UcZfWVJYisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.072
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.078
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.084
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.089
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.095
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.100
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.108
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.UcZfWVJY => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.118
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.134
!MESSAGE buffering callback sts4.classpath.UcZfWVJY ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.140
!MESSAGE executing callback sts4.classpath.UcZfWVJY 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:39.145
!MESSAGE executing callback sts4.classpath.UcZfWVJY FAILED

!ENTRY org.springframework.tooling.ls.eclipse.commons 4 0 2020-11-11 18:11:39.150
!MESSAGE 
!STACK 0
java.lang.UnsupportedOperationException: No language server has registered to handle command 'sts4.classpath.UcZfWVJY'
	at org.springframework.tooling.ls.eclipse.commons.LSP4ECommandExecutor.executeClientCommand(LSP4ECommandExecutor.java:42)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.flush(SendClasspathNotificationsJob.java:178)
	at org.springframework.tooling.jdt.ls.commons.classpath.SendClasspathNotificationsJob.run(SendClasspathNotificationsJob.java:149)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:46.958
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:46.963
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@23f37949[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:46.968
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.909
!MESSAGE Boot LS startup time from start to initialized: 1934ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.944
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.kTgfvOzlisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.950
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.957
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.966
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.973
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.979
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.984
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:48.991
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.kTgfvOzl => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:49.003
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:49.014
!MESSAGE buffering callback sts4.classpath.kTgfvOzl ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:49.019
!MESSAGE executing callback sts4.classpath.kTgfvOzl 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:11:49.045
!MESSAGE executing callback sts4.classpath.kTgfvOzl SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:21:34.704
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.kTgfvOzl

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:21:34.712
!MESSAGE unsubscribing from classpath changes: sts4.classpath.kTgfvOzl

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:21:34.717
!MESSAGE subsribers = {sts4.classpath.UcZfWVJY=Send Classpath Notifications(1503)}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 18:21:34.722
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.kTgfvOzl => OK
!SESSION 2020-11-11 20:13:58.961 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-11 20:14:07.400
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-11 20:14:07.400
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-11 20:14:10.755
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-11 20:14:10.755
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8d23cd8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5feaafb3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-11-11 20:14:23.350
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:16.438
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:16.445
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7fcbed77[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:16.460
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:16.635
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.537
!MESSAGE Boot LS startup time from start to initialized: 3061ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.817
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.QIZzxjlVisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.824
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.830
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.838
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.847
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.852
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.856
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.862
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.QIZzxjlV => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.902
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.921
!MESSAGE buffering callback sts4.classpath.QIZzxjlV ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.926
!MESSAGE executing callback sts4.classpath.QIZzxjlV 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:19.967
!MESSAGE executing callback sts4.classpath.QIZzxjlV SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-11 20:15:21.446
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:28.503
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.QIZzxjlV

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:28.509
!MESSAGE unsubscribing from classpath changes: sts4.classpath.QIZzxjlV

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:28.516
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:28.522
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.QIZzxjlV => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:38.331
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:38.336
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7fcbed77[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:38.340
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.489
!MESSAGE Boot LS startup time from start to initialized: 2143ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.514
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.iyXLBwLGisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.518
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.523
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.528
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.532
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.537
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.542
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.546
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.iyXLBwLG => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.555
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.566
!MESSAGE buffering callback sts4.classpath.iyXLBwLG ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.571
!MESSAGE executing callback sts4.classpath.iyXLBwLG 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-11 20:15:40.595
!MESSAGE executing callback sts4.classpath.iyXLBwLG SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 00:18:57.168
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.iyXLBwLG

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 00:18:57.174
!MESSAGE unsubscribing from classpath changes: sts4.classpath.iyXLBwLG

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 00:18:57.178
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 00:18:57.184
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.iyXLBwLG => OK
!SESSION 2020-11-12 08:52:20.353 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-12 08:52:27.447
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-12 08:52:27.447
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-12 08:52:31.080
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-12 08:52:31.080
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@669469c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f39ad3f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-11-12 08:52:44.749
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:52.184
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:52.184
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@545ffe1[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:52.199
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:52.384
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.211
!MESSAGE Boot LS startup time from start to initialized: 2996ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.524
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.qkSYLxyRisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.524
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.539
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.539
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.555
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.555
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.555
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.571
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.qkSYLxyR => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.586
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.602
!MESSAGE buffering callback sts4.classpath.qkSYLxyR ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.617
!MESSAGE executing callback sts4.classpath.qkSYLxyR 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:52:55.633
!MESSAGE executing callback sts4.classpath.qkSYLxyR SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-12 08:53:00.273
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:04.475
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.qkSYLxyR

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:04.475
!MESSAGE unsubscribing from classpath changes: sts4.classpath.qkSYLxyR

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:04.475
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:04.490
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.qkSYLxyR => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:12.133
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:12.138
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@545ffe1[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:12.142
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.203
!MESSAGE Boot LS startup time from start to initialized: 2055ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.283
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.FzOTFWtyisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.290
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.297
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.304
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.310
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.316
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.323
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.FzOTFWty => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.329
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.345
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.359
!MESSAGE buffering callback sts4.classpath.FzOTFWty ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.365
!MESSAGE executing callback sts4.classpath.FzOTFWty 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 08:53:14.436
!MESSAGE executing callback sts4.classpath.FzOTFWty SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 10:59:03.062
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.FzOTFWty

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 10:59:03.068
!MESSAGE unsubscribing from classpath changes: sts4.classpath.FzOTFWty

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 10:59:03.072
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 10:59:03.078
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.FzOTFWty => OK
!SESSION 2020-11-12 10:59:17.624 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-12 11:00:01.254
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-12 11:00:01.255
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-12 11:00:02.916
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-12 11:00:02.916
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@138d978e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@357e7113,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-11-12 11:00:12.117
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:20.428
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:20.437
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@6dd65b79[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:20.444
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:20.479
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.166
!MESSAGE Boot LS startup time from start to initialized: 2707ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.362
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.MdvmJQayisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.370
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.377
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.385
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.395
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.402
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.408
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.415
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.MdvmJQay => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.431
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.451
!MESSAGE buffering callback sts4.classpath.MdvmJQay ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.461
!MESSAGE executing callback sts4.classpath.MdvmJQay 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:23.502
!MESSAGE executing callback sts4.classpath.MdvmJQay SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-12 11:00:26.091
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:29.886
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.MdvmJQay

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:29.893
!MESSAGE unsubscribing from classpath changes: sts4.classpath.MdvmJQay

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:29.900
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:29.907
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.MdvmJQay => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:31.871
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:31.876
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@6dd65b79[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:31.880
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.089
!MESSAGE Boot LS startup time from start to initialized: 2204ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.118
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.XHtbXOzIisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.124
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.131
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.138
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.143
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.157
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.163
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.167
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.XHtbXOzI => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.176
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.187
!MESSAGE buffering callback sts4.classpath.XHtbXOzI ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.192
!MESSAGE executing callback sts4.classpath.XHtbXOzI 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:00:34.215
!MESSAGE executing callback sts4.classpath.XHtbXOzI SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:01:00.255
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.XHtbXOzI

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:01:00.260
!MESSAGE unsubscribing from classpath changes: sts4.classpath.XHtbXOzI

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:01:00.265
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:01:00.270
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.XHtbXOzI => OK
!SESSION 2020-11-12 11:02:01.330 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-12 11:02:07.834
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-12 11:02:07.834
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-12 11:02:09.409
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-12 11:02:09.409
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@8d23cd8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5feaafb3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:22.033
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:22.040
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1727aa28[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:22.051
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:22.110
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-12 11:02:25.441
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:25.997
!MESSAGE Boot LS startup time from start to initialized: 3896ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.410
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ptzxGCgCisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.419
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.427
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.435
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.444
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.449
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.455
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ptzxGCgC => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.462
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.489
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.506
!MESSAGE buffering callback sts4.classpath.ptzxGCgC ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.513
!MESSAGE executing callback sts4.classpath.ptzxGCgC 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 11:02:26.552
!MESSAGE executing callback sts4.classpath.ptzxGCgC SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 20:38:40.761
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ptzxGCgC

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 20:38:40.768
!MESSAGE unsubscribing from classpath changes: sts4.classpath.ptzxGCgC

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 20:38:40.773
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 20:38:40.780
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ptzxGCgC => OK

!ENTRY org.eclipse.ui 2 2 2020-11-12 20:38:41.512
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-12 21:39:40.035 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-12 21:40:03.079
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-12 21:40:03.079
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-12 21:40:06.690
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-12 21:40:06.691
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7524125c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7612f385,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-11-12 21:40:18.949
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:47.893
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:47.898
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@20961f8b[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:47.913
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:48.050
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.115
!MESSAGE Boot LS startup time from start to initialized: 3187ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.472
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.yLhZzEVNisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.480
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.485
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.493
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.502
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.508
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.514
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.520
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.yLhZzEVN => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.559
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.580
!MESSAGE buffering callback sts4.classpath.yLhZzEVN ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.584
!MESSAGE executing callback sts4.classpath.yLhZzEVN 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:51.615
!MESSAGE executing callback sts4.classpath.yLhZzEVN SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-12 21:40:54.122
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:58.962
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.yLhZzEVN

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:58.968
!MESSAGE unsubscribing from classpath changes: sts4.classpath.yLhZzEVN

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:58.975
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:40:58.981
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.yLhZzEVN => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:02.081
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:02.086
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@20961f8b[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:02.090
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.613
!MESSAGE Boot LS startup time from start to initialized: 2517ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.708
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.vmOaKnfdisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.715
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.723
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.730
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.737
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.744
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.750
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.757
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.vmOaKnfd => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.769
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.789
!MESSAGE buffering callback sts4.classpath.vmOaKnfd ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.798
!MESSAGE executing callback sts4.classpath.vmOaKnfd 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-12 21:41:04.830
!MESSAGE executing callback sts4.classpath.vmOaKnfd SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-12 22:21:43.703
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:27:23.975
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:29:07.707
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:34:18.465
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jface 2 0 2020-11-12 22:34:47.235
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-12 22:34:47.235
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73092f5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3fbe3c03,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.eclipse.jdt.debug 4 5010 2020-11-12 22:36:52.468
!MESSAGE com.sun.jdi.ObjectCollectedException occurred while retrieving value.
!STACK 0
com.sun.jdi.ObjectCollectedException
	at org.eclipse.jdi.internal.MirrorImpl.defaultReplyErrorHandler(MirrorImpl.java:282)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValues(ArrayReferenceImpl.java:134)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValue(ArrayReferenceImpl.java:76)
	at org.eclipse.jdt.internal.debug.core.model.JDIArrayEntryVariable.retrieveValue(JDIArrayEntryVariable.java:91)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:74)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:98)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeLogicalStructureAdornmentFlags(JDIModelPresentation.java:1170)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:945)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:713)
	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:129)
	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:138)
	at org.eclipse.debug.internal.ui.views.launch.DebugElementHelper.getImageDescriptor(DebugElementHelper.java:61)
	at org.eclipse.debug.internal.ui.model.elements.DebugElementLabelProvider.getImageDescriptor(DebugElementLabelProvider.java:82)
	at org.eclipse.debug.internal.ui.model.elements.VariableLabelProvider.getImageDescriptor(VariableLabelProvider.java:67)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.getImageDescriptor(ElementLabelProvider.java:274)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.retrieveLabel(ElementLabelProvider.java:201)
	at org.eclipse.jdt.internal.debug.ui.variables.JavaVariableLabelProvider.retrieveLabel(JavaVariableLabelProvider.java:186)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelUpdater.run(ElementLabelProvider.java:147)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelJob.run(ElementLabelProvider.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 4 5010 2020-11-12 22:39:09.252
!MESSAGE com.sun.jdi.ObjectCollectedException occurred while retrieving value.
!STACK 0
com.sun.jdi.ObjectCollectedException
	at org.eclipse.jdi.internal.MirrorImpl.defaultReplyErrorHandler(MirrorImpl.java:282)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValues(ArrayReferenceImpl.java:134)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValue(ArrayReferenceImpl.java:76)
	at org.eclipse.jdt.internal.debug.core.model.JDIArrayEntryVariable.retrieveValue(JDIArrayEntryVariable.java:91)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:74)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:98)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeLogicalStructureAdornmentFlags(JDIModelPresentation.java:1170)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:945)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:713)
	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:129)
	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:138)
	at org.eclipse.debug.internal.ui.views.launch.DebugElementHelper.getImageDescriptor(DebugElementHelper.java:61)
	at org.eclipse.debug.internal.ui.model.elements.DebugElementLabelProvider.getImageDescriptor(DebugElementLabelProvider.java:82)
	at org.eclipse.debug.internal.ui.model.elements.VariableLabelProvider.getImageDescriptor(VariableLabelProvider.java:67)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.getImageDescriptor(ElementLabelProvider.java:274)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.retrieveLabel(ElementLabelProvider.java:201)
	at org.eclipse.jdt.internal.debug.ui.variables.JavaVariableLabelProvider.retrieveLabel(JavaVariableLabelProvider.java:186)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelUpdater.run(ElementLabelProvider.java:147)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelJob.run(ElementLabelProvider.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 4 5010 2020-11-12 22:39:09.261
!MESSAGE com.sun.jdi.ObjectCollectedException occurred while retrieving value.
!STACK 0
com.sun.jdi.ObjectCollectedException
	at org.eclipse.jdi.internal.MirrorImpl.defaultReplyErrorHandler(MirrorImpl.java:282)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValues(ArrayReferenceImpl.java:134)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValue(ArrayReferenceImpl.java:76)
	at org.eclipse.jdt.internal.debug.core.model.JDIArrayEntryVariable.retrieveValue(JDIArrayEntryVariable.java:91)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:74)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:98)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeLogicalStructureAdornmentFlags(JDIModelPresentation.java:1170)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:945)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:713)
	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:129)
	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:138)
	at org.eclipse.debug.internal.ui.views.launch.DebugElementHelper.getImageDescriptor(DebugElementHelper.java:61)
	at org.eclipse.debug.internal.ui.model.elements.DebugElementLabelProvider.getImageDescriptor(DebugElementLabelProvider.java:82)
	at org.eclipse.debug.internal.ui.model.elements.VariableLabelProvider.getImageDescriptor(VariableLabelProvider.java:67)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.getImageDescriptor(ElementLabelProvider.java:274)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.retrieveLabel(ElementLabelProvider.java:201)
	at org.eclipse.jdt.internal.debug.ui.variables.JavaVariableLabelProvider.retrieveLabel(JavaVariableLabelProvider.java:186)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelUpdater.run(ElementLabelProvider.java:147)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelJob.run(ElementLabelProvider.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 4 5010 2020-11-12 22:39:09.269
!MESSAGE com.sun.jdi.ObjectCollectedException occurred while retrieving value.
!STACK 0
com.sun.jdi.ObjectCollectedException
	at org.eclipse.jdi.internal.MirrorImpl.defaultReplyErrorHandler(MirrorImpl.java:282)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValues(ArrayReferenceImpl.java:134)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValue(ArrayReferenceImpl.java:76)
	at org.eclipse.jdt.internal.debug.core.model.JDIArrayEntryVariable.retrieveValue(JDIArrayEntryVariable.java:91)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:74)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:98)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeLogicalStructureAdornmentFlags(JDIModelPresentation.java:1170)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:945)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:713)
	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:129)
	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:138)
	at org.eclipse.debug.internal.ui.views.launch.DebugElementHelper.getImageDescriptor(DebugElementHelper.java:61)
	at org.eclipse.debug.internal.ui.model.elements.DebugElementLabelProvider.getImageDescriptor(DebugElementLabelProvider.java:82)
	at org.eclipse.debug.internal.ui.model.elements.VariableLabelProvider.getImageDescriptor(VariableLabelProvider.java:67)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.getImageDescriptor(ElementLabelProvider.java:274)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.retrieveLabel(ElementLabelProvider.java:201)
	at org.eclipse.jdt.internal.debug.ui.variables.JavaVariableLabelProvider.retrieveLabel(JavaVariableLabelProvider.java:186)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelUpdater.run(ElementLabelProvider.java:147)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelJob.run(ElementLabelProvider.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 4 5010 2020-11-12 22:39:09.276
!MESSAGE com.sun.jdi.ObjectCollectedException occurred while retrieving value.
!STACK 0
com.sun.jdi.ObjectCollectedException
	at org.eclipse.jdi.internal.MirrorImpl.defaultReplyErrorHandler(MirrorImpl.java:282)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValues(ArrayReferenceImpl.java:134)
	at org.eclipse.jdi.internal.ArrayReferenceImpl.getValue(ArrayReferenceImpl.java:76)
	at org.eclipse.jdt.internal.debug.core.model.JDIArrayEntryVariable.retrieveValue(JDIArrayEntryVariable.java:91)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getCurrentValue(JDIVariable.java:74)
	at org.eclipse.jdt.internal.debug.core.model.JDIVariable.getValue(JDIVariable.java:98)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.computeLogicalStructureAdornmentFlags(JDIModelPresentation.java:1170)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getVariableImage(JDIModelPresentation.java:945)
	at org.eclipse.jdt.internal.debug.ui.JDIModelPresentation.getImage(JDIModelPresentation.java:713)
	at org.eclipse.debug.internal.ui.LazyModelPresentation.getImage(LazyModelPresentation.java:129)
	at org.eclipse.debug.internal.ui.DelegatingModelPresentation.getImage(DelegatingModelPresentation.java:138)
	at org.eclipse.debug.internal.ui.views.launch.DebugElementHelper.getImageDescriptor(DebugElementHelper.java:61)
	at org.eclipse.debug.internal.ui.model.elements.DebugElementLabelProvider.getImageDescriptor(DebugElementLabelProvider.java:82)
	at org.eclipse.debug.internal.ui.model.elements.VariableLabelProvider.getImageDescriptor(VariableLabelProvider.java:67)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.getImageDescriptor(ElementLabelProvider.java:274)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider.retrieveLabel(ElementLabelProvider.java:201)
	at org.eclipse.jdt.internal.debug.ui.variables.JavaVariableLabelProvider.retrieveLabel(JavaVariableLabelProvider.java:186)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelUpdater.run(ElementLabelProvider.java:147)
	at org.eclipse.debug.internal.ui.model.elements.ElementLabelProvider$LabelJob.run(ElementLabelProvider.java:74)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:40:18.046
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-12 22:40:36.148
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-12 22:40:44.002
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:44:17.173
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:45:06.987
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:56:09.046
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 22:56:51.302
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:00:01.692
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-12 23:00:34.745
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:00:43.768
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-12 23:00:43.941
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:07:57.806
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-12 23:07:58.023
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:13:27.063
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:15:41.421
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:19:30.173
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug.ui 4 150 2020-11-12 23:24:50.796
!MESSAGE Internal Error
!STACK 0
org.eclipse.jface.text.BadLocationException
	at org.eclipse.jface.text.TreeLineTracker.fail(TreeLineTracker.java:1054)
	at org.eclipse.jface.text.TreeLineTracker.lineByOffset(TreeLineTracker.java:268)
	at org.eclipse.jface.text.TreeLineTracker.getLineNumberOfOffset(TreeLineTracker.java:1122)
	at org.eclipse.jface.text.AbstractLineTracker.getLineNumberOfOffset(AbstractLineTracker.java:155)
	at org.eclipse.jface.text.AbstractDocument.getLineOfOffset(AbstractDocument.java:872)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.getLineOfOffset(SynchronizableDocument.java:334)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.findExistingBreakpoint(ToggleBreakpointAdapter.java:1382)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleFieldOrMethodBreakpoints(ToggleBreakpointAdapter.java:1409)
	at org.eclipse.jdt.internal.debug.ui.actions.ToggleBreakpointAdapter.toggleBreakpoints(ToggleBreakpointAdapter.java:1343)
	at org.eclipse.debug.internal.ui.actions.breakpoints.RetargetToggleBreakpointAction.performAction(RetargetToggleBreakpointAction.java:34)
	at org.eclipse.debug.internal.ui.actions.RetargetAction.run(RetargetAction.java:103)
	at org.eclipse.debug.internal.ui.actions.RetargetAction.runWithEvent(RetargetAction.java:246)
	at org.eclipse.ui.internal.handlers.ActionDelegateHandlerProxy.execute(ActionDelegateHandlerProxy.java:281)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at sun.reflect.GeneratedMethodAccessor91.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:319)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:253)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:584)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:653)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:443)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.access$2(KeyBindingDispatcher.java:386)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1248)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1036)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1046)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1088)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.wmChar(Widget.java:1471)
	at org.eclipse.swt.widgets.Control.WM_CHAR(Control.java:4862)
	at org.eclipse.swt.widgets.Canvas.WM_CHAR(Canvas.java:345)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4740)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:340)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4923)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3628)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.debug.ui 4 150 2020-11-12 23:24:54.033
!MESSAGE Internal Error
!STACK 0
org.eclipse.jface.text.BadLocationException
	at org.eclipse.jface.text.TreeLineTracker.fail(TreeLineTracker.java:1054)
	at org.eclipse.jface.text.TreeLineTracker.lineByOffset(TreeLineTracker.java:268)
	at org.eclipse.jface.text.TreeLineTracker.getLineNumberOfOffset(TreeLineTracker.java:1122)
	at org.eclipse.jface.text.AbstractLineTracker.getLineNumberOfOffset(AbstractLineTracker.java:155)
	at org.eclipse.jface.text.AbstractDocument.getLineOfOffset(AbstractDocument.java:872)
	at org.eclipse.core.internal.filebuffers.SynchronizableDocument.getLineOfOffset(SynchronizableDocument.java:334)
	at org.eclipse.jdt.internal.debug.ui.BreakpointMarkerUpdater.updateMarker(BreakpointMarkerUpdater.java:116)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarker(AbstractMarkerAnnotationModel.java:578)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.updateMarkers(AbstractMarkerAnnotationModel.java:638)
	at org.eclipse.ui.texteditor.AbstractMarkerAnnotationModel.commit(AbstractMarkerAnnotationModel.java:701)
	at org.eclipse.core.internal.filebuffers.ResourceTextFileBuffer.commitFileBufferContent(ResourceTextFileBuffer.java:366)
	at org.eclipse.core.internal.filebuffers.ResourceFileBuffer.commit(ResourceFileBuffer.java:317)
	at org.eclipse.jdt.internal.ui.javaeditor.DocumentAdapter.save(DocumentAdapter.java:516)
	at org.eclipse.jdt.internal.core.CommitWorkingCopyOperation.executeOperation(CommitWorkingCopyOperation.java:127)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:807)
	at org.eclipse.jdt.internal.core.CompilationUnit.commitWorkingCopy(CompilationUnit.java:404)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider.commitWorkingCopy(CompilationUnitDocumentProvider.java:1422)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitDocumentProvider$4.execute(CompilationUnitDocumentProvider.java:1503)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider$DocumentProviderOperation.run(TextFileDocumentProvider.java:133)
	at org.eclipse.ui.actions.WorkspaceModifyDelegatingOperation.execute(WorkspaceModifyDelegatingOperation.java:71)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.lambda$0(WorkspaceModifyOperation.java:110)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2292)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2317)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.saveDocument(TextFileDocumentProvider.java:764)
	at org.eclipse.ui.texteditor.AbstractTextEditor.performSave(AbstractTextEditor.java:5062)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.performSave(CompilationUnitEditor.java:1275)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1329)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7198)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveablesList.lambda$2(SaveablesList.java:850)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:2375)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2373)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:858)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:822)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3460)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.ui.internal.UISynchronizer.lambda$0(UISynchronizer.java:139)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4005)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3633)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1158)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1047)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:658)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:154)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:657)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:594)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1447)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:24:54.495
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-12 23:27:38.408
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 03:38:01.685
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.vmOaKnfd

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 03:38:01.698
!MESSAGE unsubscribing from classpath changes: sts4.classpath.vmOaKnfd

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 03:38:01.703
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 03:38:01.707
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.vmOaKnfd => OK
!SESSION 2020-11-13 09:00:58.016 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-13 09:01:07.068
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-13 09:01:07.068
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-13 09:01:11.573
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-13 09:01:11.573
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7f39ad3f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7524125c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:25.433
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:25.433
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@76c974b[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:25.448
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:25.618
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:28.875
!MESSAGE Boot LS startup time from start to initialized: 3405ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.479
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.NTAPtvNOisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.494
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.494
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.510
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.526
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.541
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.541
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.557
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.NTAPtvNO => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.572
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.588
!MESSAGE buffering callback sts4.classpath.NTAPtvNO ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.588
!MESSAGE executing callback sts4.classpath.NTAPtvNO 1 batched events

!ENTRY org.eclipse.egit.ui 2 0 2020-11-13 09:01:29.635
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 09:01:29.666
!MESSAGE executing callback sts4.classpath.NTAPtvNO SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-13 14:15:03.299
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-13 14:53:26.087
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-13 14:57:18.787
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 18:07:10.738
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.NTAPtvNO

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 18:07:10.776
!MESSAGE unsubscribing from classpath changes: sts4.classpath.NTAPtvNO

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 18:07:10.782
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-13 18:07:10.787
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.NTAPtvNO => OK
!SESSION 2020-11-15 22:49:10.865 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-15 22:49:49.591
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-15 22:49:49.591
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-15 22:49:53.281
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-15 22:49:53.281
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@173b24c4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@21084a6d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:08.360
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:08.365
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@3ae2721b[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:08.380
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:08.547
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.305
!MESSAGE Boot LS startup time from start to initialized: 2901ms

!ENTRY org.eclipse.egit.ui 2 0 2020-11-15 22:50:11.583
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.824
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.kDKDasFIisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.843
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.850
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.859
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.868
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.874
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.880
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.886
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.kDKDasFI => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.907
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.922
!MESSAGE buffering callback sts4.classpath.kDKDasFI ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.927
!MESSAGE executing callback sts4.classpath.kDKDasFI 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 22:50:11.965
!MESSAGE executing callback sts4.classpath.kDKDasFI SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 23:14:43.925
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.kDKDasFI

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 23:14:43.932
!MESSAGE unsubscribing from classpath changes: sts4.classpath.kDKDasFI

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 23:14:43.937
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-15 23:14:43.942
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.kDKDasFI => OK

!ENTRY org.eclipse.ui 2 2 2020-11-15 23:14:44.635
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-16 08:52:54.994 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-16 08:53:01.403
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-16 08:53:01.403
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-16 08:53:03.358
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-16 08:53:03.358
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35630ee8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e80de85,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:13.747
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:13.753
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@1bee92f9[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:13.760
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:13.829
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-16 08:53:16.578
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.247
!MESSAGE Boot LS startup time from start to initialized: 3463ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.691
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.IxqIcAQXisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.699
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.705
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.714
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.723
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.730
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.739
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.749
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.IxqIcAQX => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.765
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.777
!MESSAGE buffering callback sts4.classpath.IxqIcAQX ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.782
!MESSAGE executing callback sts4.classpath.IxqIcAQX 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 08:53:17.813
!MESSAGE executing callback sts4.classpath.IxqIcAQX SUCCESS [done]

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-16 16:47:42.843
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jface 2 0 2020-11-16 16:47:53.244
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-16 16:47:53.244
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1cfa6f7a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@611e03f6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-16 16:49:51.301
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-16 17:10:47.868
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-16 17:10:58.548
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-16 17:29:19.217
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-16 17:30:11.349
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 18:23:00.567
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.IxqIcAQX

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 18:23:00.573
!MESSAGE unsubscribing from classpath changes: sts4.classpath.IxqIcAQX

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 18:23:00.578
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 18:23:00.582
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.IxqIcAQX => OK

!ENTRY org.eclipse.ui 2 2 2020-11-16 18:23:01.404
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-16 19:06:03.528 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-16 19:06:13.037
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-16 19:06:13.037
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-16 19:06:16.916
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-16 19:06:16.916
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c3114ea,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@642d971f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:30.223
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:30.228
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@2655ad3b[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:30.242
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:30.397
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-16 19:06:33.897
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.277
!MESSAGE Boot LS startup time from start to initialized: 4013ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.852
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ShJcVxXKisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.859
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.867
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.875
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.884
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.891
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.898
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.ShJcVxXK => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.905
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.928
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.945
!MESSAGE buffering callback sts4.classpath.ShJcVxXK ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:34.952
!MESSAGE executing callback sts4.classpath.ShJcVxXK 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-16 19:06:35.029
!MESSAGE executing callback sts4.classpath.ShJcVxXK SUCCESS [done]

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-16 20:09:15.145
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-16 20:09:25.926
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-16 20:09:35.417
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-16 20:36:20.870
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 02:23:30.448
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ShJcVxXK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 02:23:30.453
!MESSAGE unsubscribing from classpath changes: sts4.classpath.ShJcVxXK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 02:23:30.459
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 02:23:30.464
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.ShJcVxXK => OK

!ENTRY org.eclipse.ui 2 2 2020-11-17 02:23:31.213
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-17 09:03:17.274 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-17 09:04:10.784
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-17 09:04:10.784
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-17 09:04:12.653
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-17 09:04:12.653
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2afe825a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49c6ee4a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:20.488
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:20.495
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@250988e5[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:20.504
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:20.588
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:23.618
!MESSAGE Boot LS startup time from start to initialized: 3061ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.196
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.JVkHFLYQisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.205
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.212
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.221
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.235
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.242
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.249
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.257
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.JVkHFLYQ => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.295
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.314
!MESSAGE buffering callback sts4.classpath.JVkHFLYQ ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.327
!MESSAGE executing callback sts4.classpath.JVkHFLYQ 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 09:04:24.417
!MESSAGE executing callback sts4.classpath.JVkHFLYQ SUCCESS [done]

!ENTRY org.eclipse.egit.ui 2 0 2020-11-17 09:04:24.494
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 2 2 2020-11-17 10:40:23.546
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-17 10:40:35.033
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 18:15:11.450
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.JVkHFLYQ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 18:15:11.466
!MESSAGE unsubscribing from classpath changes: sts4.classpath.JVkHFLYQ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 18:15:11.473
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 18:15:11.480
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.JVkHFLYQ => OK
!SESSION 2020-11-17 19:33:29.061 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-17 19:33:38.133
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-17 19:33:38.133
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-17 19:33:41.725
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-17 19:33:41.725
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e7cb01a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@236206f8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:33:56.815
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:33:56.823
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7ef7f6d5[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:33:56.840
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:33:57.041
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-17 19:34:00.538
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.019
!MESSAGE Boot LS startup time from start to initialized: 5157ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.466
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.jJzFQRPFisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.474
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.482
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.490
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.499
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.506
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.513
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.525
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.jJzFQRPF => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.566
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.581
!MESSAGE buffering callback sts4.classpath.jJzFQRPF ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.586
!MESSAGE executing callback sts4.classpath.jJzFQRPF 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:34:02.633
!MESSAGE executing callback sts4.classpath.jJzFQRPF SUCCESS [done]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:34.731
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.jJzFQRPF

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:34.736
!MESSAGE unsubscribing from classpath changes: sts4.classpath.jJzFQRPF

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:34.742
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:34.747
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.jJzFQRPF => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:35.687
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:35.691
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@7ef7f6d5[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:35.695
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.757
!MESSAGE Boot LS startup time from start to initialized: 2056ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.784
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.kxFVDIUoisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.789
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.796
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.802
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.806
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.812
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.816
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.821
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.kxFVDIUo => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.834
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.850
!MESSAGE buffering callback sts4.classpath.kxFVDIUo ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.854
!MESSAGE executing callback sts4.classpath.kxFVDIUo 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-17 19:45:37.874
!MESSAGE executing callback sts4.classpath.kxFVDIUo SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-17 20:22:25.262
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:15:45.904
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.kxFVDIUo

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:15:45.919
!MESSAGE unsubscribing from classpath changes: sts4.classpath.kxFVDIUo

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:15:45.919
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:15:45.919
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.kxFVDIUo => OK
!SESSION 2020-11-18 09:17:27.830 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-18 09:17:40.504
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-18 09:17:40.504
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-18 09:17:43.909
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-18 09:17:43.909
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7524125c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7612f385,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:17:56.453
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:17:56.453
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@299d1bd6[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:17:56.469
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:17:56.625
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-18 09:17:58.451
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.044
!MESSAGE Boot LS startup time from start to initialized: 3559ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.372
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.edILkEeaisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.372
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.372
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.388
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.388
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.404
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.419
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.419
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.edILkEea => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.451
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.466
!MESSAGE buffering callback sts4.classpath.edILkEea ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.466
!MESSAGE executing callback sts4.classpath.edILkEea 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 09:18:00.497
!MESSAGE executing callback sts4.classpath.edILkEea SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-18 09:21:16.686
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-18 10:40:28.703
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-18 16:05:24.740
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.util.concurrent.CompletableFuture.timedGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-18 16:52:55.963
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-18 16:54:40.160
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:08:08.024
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.edILkEea

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:08:08.029
!MESSAGE unsubscribing from classpath changes: sts4.classpath.edILkEea

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:08:08.035
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:08:08.040
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.edILkEea => OK
!SESSION 2020-11-18 18:09:26.900 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-18 18:09:37.979
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-18 18:09:37.979
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-18 18:09:43.091
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-18 18:09:43.091
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2afe825a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@49c6ee4a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:09:59.004
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:09:59.009
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@76ed5e7e[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:09:59.023
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:09:59.199
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-18 18:10:01.825
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:03.589
!MESSAGE Boot LS startup time from start to initialized: 4543ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.038
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.CcGJISTwisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.045
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.053
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.061
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.079
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.086
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.092
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.099
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.CcGJISTw => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.118
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.131
!MESSAGE buffering callback sts4.classpath.CcGJISTw ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.149
!MESSAGE executing callback sts4.classpath.CcGJISTw 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-18 18:10:04.190
!MESSAGE executing callback sts4.classpath.CcGJISTw SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-23 08:53:47.314
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2020-11-23 09:00:31.308
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.jface 2 0 2020-11-23 10:56:39.134
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-23 10:56:39.134
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@454e94d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4763fed6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:28:33.601
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.CcGJISTw

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:28:33.607
!MESSAGE unsubscribing from classpath changes: sts4.classpath.CcGJISTw

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:28:33.614
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:28:33.619
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.CcGJISTw => OK
!SESSION 2020-11-23 11:28:49.723 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-23 11:28:56.446
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-23 11:28:56.446
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-23 11:28:59.528
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-23 11:28:59.528
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4549d616,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bfb60b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:07.428
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:07.432
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@6d6e8dfc[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:07.446
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:07.506
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.jface 2 0 2020-11-23 11:29:08.841
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-23 11:29:08.842
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36f291c7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5db3afff,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.110
!MESSAGE Boot LS startup time from start to initialized: 2623ms

!ENTRY org.eclipse.egit.ui 2 0 2020-11-23 11:29:10.233
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.592
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.DqzOYtFGisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.599
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.606
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.617
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.626
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.637
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.647
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:10.656
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.DqzOYtFG => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:12.315
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:12.328
!MESSAGE buffering callback sts4.classpath.DqzOYtFG ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:12.333
!MESSAGE executing callback sts4.classpath.DqzOYtFG 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 11:29:12.374
!MESSAGE executing callback sts4.classpath.DqzOYtFG SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-23 11:29:14.749
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 18:18:31.830
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.DqzOYtFG

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 18:18:31.850
!MESSAGE unsubscribing from classpath changes: sts4.classpath.DqzOYtFG

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 18:18:31.855
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 18:18:31.860
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.DqzOYtFG => OK
!SESSION 2020-11-23 20:39:35.185 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-23 20:39:43.151
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-23 20:39:43.151
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-23 20:39:47.041
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-23 20:39:47.041
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9a74a93,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@255d4d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2020-11-23 20:40:03.621
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:57:59.580
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:57:59.585
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@250268ef[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:57:59.600
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:57:59.743
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.493
!MESSAGE Boot LS startup time from start to initialized: 2878ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.760
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.CGlCHBfQisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.768
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.773
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.779
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.785
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.790
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.795
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.801
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.CGlCHBfQ => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.818
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.829
!MESSAGE buffering callback sts4.classpath.CGlCHBfQ ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.834
!MESSAGE executing callback sts4.classpath.CGlCHBfQ 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-23 20:58:02.879
!MESSAGE executing callback sts4.classpath.CGlCHBfQ SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-24 16:40:40.116
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-24 16:40:42.138
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-24 17:04:36.856
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-24 18:16:44.908
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 18:18:52.023
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.CGlCHBfQ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 18:18:52.028
!MESSAGE unsubscribing from classpath changes: sts4.classpath.CGlCHBfQ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 18:18:52.034
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 18:18:52.039
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.CGlCHBfQ => OK

!ENTRY org.eclipse.ui 2 2 2020-11-24 18:18:52.904
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-24 19:03:47.609 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-24 19:03:58.674
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-24 19:03:58.674
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-24 19:04:03.670
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-24 19:04:03.670
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bfb60b7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@65b1693c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:19.648
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:19.653
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@6f96c70b[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:19.666
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:19.856
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-24 19:04:23.306
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:24.882
!MESSAGE Boot LS startup time from start to initialized: 5193ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.289
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.SwBrMixTisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.297
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.304
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.312
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.321
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.328
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.334
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.340
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.SwBrMixT => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.384
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.399
!MESSAGE buffering callback sts4.classpath.SwBrMixT ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.405
!MESSAGE executing callback sts4.classpath.SwBrMixT 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-24 19:04:25.465
!MESSAGE executing callback sts4.classpath.SwBrMixT SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 09:24:16.812
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2020-11-25 10:54:10.415
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:30.205
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.SwBrMixT

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:30.210
!MESSAGE unsubscribing from classpath changes: sts4.classpath.SwBrMixT

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:30.215
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:30.221
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.SwBrMixT => OK
!SESSION 2020-11-25 10:56:33.967 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-25 10:56:44.335
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-25 10:56:44.335
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-25 10:56:47.674
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-25 10:56:47.674
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@33622388,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2e03bb74,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:59.637
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:59.642
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@27c510c5[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:59.655
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:56:59.847
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-11-25 10:57:02.456
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.401
!MESSAGE Boot LS startup time from start to initialized: 3725ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.744
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.fEfrFyLaisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.750
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.756
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.763
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.770
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.775
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.780
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.786
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.fEfrFyLa => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.823
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.833
!MESSAGE buffering callback sts4.classpath.fEfrFyLa ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.838
!MESSAGE executing callback sts4.classpath.fEfrFyLa 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 10:57:03.867
!MESSAGE executing callback sts4.classpath.fEfrFyLa SUCCESS [done]

!ENTRY org.eclipse.ui 2 2 2020-11-25 14:29:22.580
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.jface 2 0 2020-11-25 16:06:05.568
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-25 16:06:05.568
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c0c16ef,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@55db0ecd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 16:34:28.627
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 20:40:40.164
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 20:46:40.577
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 20:47:13.542
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 21:26:35.290
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 21:28:03.474
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 21:30:30.032
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jface 2 0 2020-11-25 21:30:53.717
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-25 21:30:53.717
!MESSAGE A conflict occurred for CTRL+R:
Binding(CTRL+R,
	ParameterizedCommand(Command(org.eclipse.debug.ui.commands.RunToLine,Run to Line,
		Resume and break when execution reaches the current line,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e4389bf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.debugging,,,system)
Binding(CTRL+R,
	ParameterizedCommand(Command(org.springframework.ide.eclipse.boot.restart.commands.restart,Trigger Restart,
		Restart Spring Boot Application,
		Category(org.eclipse.debug.ui.category.run,Run/Debug,Run/Debug command category,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3c9c4676,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.debug.ui.console,,,system)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 21:31:55.672
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 21:43:07.538
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 21:54:48.403
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 21:55:23.864
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 21:59:54.816
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 23:02:00.437
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 23:03:35.683
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 23:10:06.736
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 23:10:18.746
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 23:10:56.205
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2020-11-25 23:14:51.703
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:26:35.640
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.fEfrFyLa

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:26:35.703
!MESSAGE unsubscribing from classpath changes: sts4.classpath.fEfrFyLa

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:26:35.708
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:26:35.714
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.fEfrFyLa => OK
!SESSION 2020-11-25 23:28:31.628 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-25 23:28:38.937
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-25 23:28:38.937
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-25 23:28:42.137
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-25 23:28:42.137
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@426bf2f2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2cfd9b0a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:51.005
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:51.010
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@4bfaa7b[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:51.023
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:51.232
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.160
!MESSAGE Boot LS startup time from start to initialized: 3077ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.795
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.uXZbalyJisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.806
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.814
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.825
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.836
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.843
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.850
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.857
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.uXZbalyJ => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.925
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.940
!MESSAGE buffering callback sts4.classpath.uXZbalyJ ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:54.949
!MESSAGE executing callback sts4.classpath.uXZbalyJ 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-25 23:28:55.038
!MESSAGE executing callback sts4.classpath.uXZbalyJ SUCCESS [done]

!ENTRY org.eclipse.egit.ui 2 0 2020-11-25 23:28:55.316
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.lsp4e 2 0 2020-11-25 23:31:03.865
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.util.concurrent.CompletableFuture.timedGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface 2 0 2020-11-25 23:57:15.928
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-25 23:57:15.928
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@74106c6c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64a65f68,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 00:00:56.319
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.uXZbalyJ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 00:00:56.326
!MESSAGE unsubscribing from classpath changes: sts4.classpath.uXZbalyJ

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 00:00:56.332
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 00:00:56.339
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.uXZbalyJ => OK

!ENTRY org.eclipse.ui 2 2 2020-11-26 00:00:56.906
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
!SESSION 2020-11-26 09:06:24.314 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-11-26 09:07:00.011
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-11-26 09:07:00.011
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-11-26 09:07:03.597
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-26 09:07:03.597
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f3dafd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@33622388,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:13.449
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:13.454
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@4b1339bf[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:13.468
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:13.722
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.jface 2 0 2020-11-26 09:07:15.860
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-11-26 09:07:15.860
!MESSAGE A conflict occurred for CTRL+SHIFT+C:
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.eclipse.tm4e.languageconfiguration.togglelinecommentcommand,Toggle Line Comment,
		,
		Category(org.eclipse.tm4e.languageconfiguration.category,TM4E Language Configuration,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6740b169,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)
Binding(CTRL+SHIFT+C,
	ParameterizedCommand(Command(org.springframework.tooling.boot.ls.ToggleComment,Toggle Comment,
		,
		Category(org.springframework.ide.eclipse.commands,Spring Generic Text Editor,Spring Language Server Commands,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@71897380,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.textEditorScope,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.039
!MESSAGE Boot LS startup time from start to initialized: 2516ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.731
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.JyEKmrxaisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.743
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.755
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.766
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.776
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.788
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.797
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.JyEKmrxa => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:16.805
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.eclipse.egit.ui 2 0 2020-11-26 09:07:17.173
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:21.041
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:21.053
!MESSAGE buffering callback sts4.classpath.JyEKmrxa ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:21.058
!MESSAGE executing callback sts4.classpath.JyEKmrxa 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-26 09:07:21.097
!MESSAGE executing callback sts4.classpath.JyEKmrxa SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-11-26 09:11:48.065
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.ui 2 2 2020-11-26 11:08:16.741
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-26 11:28:52.386
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-26 11:29:09.420
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-26 11:29:20.953
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.645
!MESSAGE No line style provider for org.eclipse.wst.sse.ST_DEFAULT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.675
!MESSAGE No line style provider for org.eclipse.wst.sse.UNKNOWN_PARTITION_TYPE

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.680
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_DEFAULT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.686
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_CDATA

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.697
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_DECL

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.701
!MESSAGE No line style provider for org.eclipse.wst.xml.XML_COMMENT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.707
!MESSAGE No line style provider for org.eclipse.wst.xml.dtd.internal_subset

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.712
!MESSAGE No line style provider for org.eclipse.wst.xml.PROCESSING_INSTRUCTION:

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.716
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT

!ENTRY org.eclipse.wst.html.ui 1 1 2020-11-27 16:06:57.723
!MESSAGE No line style provider for org.eclipse.wst.html.SCRIPT.EVENTHANDLER

!ENTRY org.eclipse.lsp4e 2 0 2020-11-27 17:12:42.397
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-11-27 17:12:45.318
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-30 15:37:02.669
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.JyEKmrxa

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-30 15:37:02.699
!MESSAGE unsubscribing from classpath changes: sts4.classpath.JyEKmrxa

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-30 15:37:02.703
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-11-30 15:37:02.708
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.JyEKmrxa => OK
!SESSION 2020-12-01 11:08:50.344 -----------------------------------------------
eclipse.buildId=4.16.0.I20200604-0540
java.version=1.8.0_251
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.ui 2 0 2020-12-01 11:08:57.539
!MESSAGE Warnings while parsing the key bindings from the 'org.eclipse.ui.commands' and 'org.eclipse.ui.bindings' extension point
!SUBENTRY 1 org.eclipse.ui 2 0 2020-12-01 11:08:57.539
!MESSAGE Defining a key binding with no key sequence has no effect: plug-in='org.springframework.ide.eclipse.boot.wizard', id='org.springframework.ide.eclipse.boot.wizard.addStarersSwitchHandler'

!ENTRY org.eclipse.jface 2 0 2020-12-01 11:09:01.182
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2020-12-01 11:09:01.182
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6e664075,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c571162,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:15.175
!MESSAGE Entering DelegatingStreamConnectionProvider()

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:15.179
!MESSAGE DelegatingStreamConnectionProvider classloader = org.eclipse.osgi.internal.loader.EquinoxClassLoader@c2c496d[org.springframework.tooling.boot.ls:1.20.0.202007271426(id=996)]

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:15.194
!MESSAGE SpringBootLanguageServer exists!

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:15.349
!MESSAGE Instantiating ReusableClasspathListenerHandler

!ENTRY org.eclipse.egit.ui 2 0 2020-12-01 11:09:18.007
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\user'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.100
!MESSAGE Boot LS startup time from start to initialized: 3882ms

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.576
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.IveOWGKIisBatched = true

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.583
!MESSAGE Creating project sorter...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.589
!MESSAGE Creating project sorter... DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.596
!MESSAGE Setting up ClasspathListenerManager

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.604
!MESSAGE Scheduling initial event for all projects ...

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.610
!MESSAGE Scheduling initial event for all projects DONE

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.616
!MESSAGE exists = true open = true => deleted = false

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.622
!MESSAGE ClasspathListenerHandler addClasspathListener sts4.classpath.IveOWGKI => OK

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.661
!MESSAGE classpath=140 entries

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.671
!MESSAGE buffering callback sts4.classpath.IveOWGKI ITSK_SmartMobility false 140

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.675
!MESSAGE executing callback sts4.classpath.IveOWGKI 1 batched events

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:09:19.712
!MESSAGE executing callback sts4.classpath.IveOWGKI SUCCESS [done]

!ENTRY org.eclipse.lsp4e 2 0 2020-12-01 11:12:14.067
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.lsp4e 2 0 2020-12-01 11:15:16.636
!MESSAGE Javadoc unavailable. Failed to obtain it.
!STACK 0
java.lang.InterruptedException
	at java.util.concurrent.CompletableFuture.reportGet(Unknown Source)
	at java.util.concurrent.CompletableFuture.get(Unknown Source)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:70)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:21:31.248
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.IveOWGKI

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:21:31.254
!MESSAGE unsubscribing from classpath changes: sts4.classpath.IveOWGKI

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:21:31.259
!MESSAGE subsribers = {}

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2020-12-01 11:21:31.264
!MESSAGE ClasspathListenerHandler removeClasspathListener sts4.classpath.IveOWGKI => OK

!ENTRY org.eclipse.ui 2 2 2020-12-01 11:21:31.812
!MESSAGE Invalid property category path: org.springframework.ide.eclipse.beans.ui.properties.ProjectPropertyPage (bundle: org.springframework.ide.eclipse.xml.namespaces, propertyPage: org.springframework.ide.eclipse.beans.ui.namespaces.projectPropertyPage)
